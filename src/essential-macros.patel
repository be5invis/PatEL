define-macro syntax-rules : lambda [form env] : macro-match form env 
	`[syntax-rules @::patterns] {'.syntactic-closure' `[lambda [form env] [begin
		[local [dirty s] {'.syntactic-closure' s env}] 
		[macro-match form env @::[patterns.map formOf]]]] env}
	otherwise : throw : new FormInvalidError form "Invalid Macro Difinition"

define-macro the-form-is-invalid : syntax-rules
	`[the-form-is-invalid] : dirty `[throw : new FormInvalidError form "Form Invalid"]
	`[the-form-is-invalid @reason] : dirty `[throw : new FormInvalidError form @reason]

define-macro set-operator-info : syntax-rules
	`[set-operator-info @{".quote" operator} @{".quote" priority} @{".quote" associvity}] : begin
		env.operatorInfo.put [formOf operator] {
			.priority [formOf priority]
			.associvity [formOf associvity]
		}
		return nothing
	`[set-operator-info @{".quote" operator} @{".quote" priority}] : begin
		env.operatorInfo.put [formOf operator] {
			.priority [formOf priority]
			.associvity "never"
		}
		return nothing
	
	otherwise : the-form-is-invalid

define-macro define-operator : syntax-rules
	`[define-operator @{".quote" operator} @{".quote" priority} @{".quote" associvity} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]} @{".quote" [formOf associvity]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator @{".quote" operator} @{".quote" priority} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator infix @{".quote" operator} @{".quote" priority} @{".quote" associvity} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]} @{".quote" [formOf associvity]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator infix @{".quote" operator} @{".quote" priority} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator prefix @{".quote" operator} @body] : dirty `[begin \\
		define-macro @{".quote" (".prefix." + [formOf operator])} @[formOf body]
	]
	
	otherwise : the-form-is-invalid

define-macro its : syntax-rules 
	`[its @property] : return `[let [t @property] [lambda [x] x.(t)]]
	otherwise : the-form-is-invalid

define-macro call-its : syntax-rules 
	`[call-its @property] : return `[let [t @property] [lambda [x] [x.(t)]]]
	`[call-its @property @::args] : return `[let [t @property] [a {@::args}] [lambda [x] [x.(t).apply x a]]]
	otherwise : the-form-is-invalid

define-macro getAllKeys : begin 
	local exoticAST {.type "FunctionExpression" .id null .params {{.type "Identifier" .name "o"}} .defaults {} .body {.type "BlockStatement" .body {{.type "VariableDeclaration" .declarations {{.type "VariableDeclarator" .id {.type "Identifier" .name "a"} .init {.type "ArrayExpression" .elements {}}}} .kind "var"} { .type "ForInStatement" .left {.type "VariableDeclaration" .declarations {{.type "VariableDeclarator" .id {.type "Identifier" .name "k"} .init null}} .kind "var"} .right {.type "Identifier" .name "o"} .body {.type "BlockStatement" .body {{.type "ExpressionStatement" .expression {.type "CallExpression" .callee { .type "MemberExpression" .computed false .object {.type "Identifier" .name "a"} .property {.type "Identifier" .name "push"} } .arguments {{.type "Identifier" .name "k"}}}}}} .each false } {.type "ReturnStatement" .argument {.type "Identifier" .name "a"}}}} .rest null .generator false .expression false }
	local t : definingEnv.newt
	#local coinitStatement : ex `[set @t @{".preserve" {".exotic" exoticAST}}] definingEnv
	set ijp {".begin"}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	define [used] : begin
		if [not ijp.1] : set ijp.1 : ex `[set @t @{".preserve" {".exotic" exoticAST}}] definingEnv

	local f : syntax-rules 
		`[getAllKeys] `{}
		`[getAllKeys @obj] : begin [used] `[@t @obj]
		`[getAllKeys @obj @::unused] : begin [used] `[@t @obj]
		otherwise : the-form-is-invalid
	set [f.invokeAsAtom] : begin [used] t
	return f

define-macro items-of : begin
	set ijp {".begin" nothing nothing nothing nothing}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	local t1 : definingEnv.newt
	define [use id] : match id
		'items-of' : if [not ijp.1] : set ijp.1 : ex `[set @t1 [lambda [t] [begin
			[local n t.length]
			[for [local i 0] (i < n) (i = i + 1) [yield t.(i)]]
		]]] definingEnv
	return : syntax-rules 
		`[items-of @obj] : begin [use 'items-of'] `[@t1 @obj]
		otherwise : throw : new FormInvalidError form "Invalid form about [items-of]"
define-macro pairs-of : begin
	set ijp {".begin" nothing nothing nothing nothing}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	define [use id] : match id
		'pairs-of-eigen' : if [not ijp.1] : begin
			local t : definingEnv.newt
			set ijp.1 : ex `[set @t [lambda [t] [begin \\
				if (t <@ Array) : then
					local n t.length
					for [local i 0] (i < n) (i = i + 1) : yield { i t.(i) }
				: else
					local a : Object.keys t
					local n a.length
					for [local i 0] (i < n) (i = i + 1) : yield { a.(i) t.(a.(i)) }
			]]] definingEnv
			return t
		'pairs-of-all' : if [not ijp.2] : begin
			local t : definingEnv.newt
			set ijp.2 : ex `[set @t [lambda [t] [begin \\
				local a : getAllKeys t
				local n a.length
				for [local i 0] (i < n) (i = i + 1) : yield { a.(i) t.(a.(i)) }
			]]] definingEnv
			return t
	return : syntax-rules 
		`[pairs-of @obj] : begin `[@[use 'pairs-of-eigen'] @obj]
		`[pairs-of all @obj] : begin `[@[use 'pairs-of-all'] @obj]
		otherwise : throw : new FormInvalidError form "Invalid form about [pairs-of]"
define-macro range : begin
	set ijp {".begin" nothing nothing nothing nothing}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	local t1 : definingEnv.newt
	local t2 : definingEnv.newt
	local t3 : definingEnv.newt
	local t4 : definingEnv.newt
	define [use id] : match id
		'upto' : if [not ijp.1] : set ijp.1 : ex `[set @t1 [lambda [lo hi] : begin \\
			for [local j lo] (j < hi) (j = j + 1) : yield j
		]] definingEnv
		'uptill' : if [not ijp.2] : set ijp.2 : ex `[set @t2 [lambda [lo hi] : begin \\
			for [local j lo] (j <= hi) (j = j + 1) : yield j
		]] definingEnv
		'downto' : if [not ijp.3] : set ijp.3 : ex `[set @t3 [lambda [lo hi] : begin \\
			for [local j lo] (j > hi) (j = j - 1) : yield j
		]] definingEnv
		'downtill' : if [not ijp.4] : set ijp.4 : ex `[set @t4 [lambda [lo hi] : begin \\
			for [local j lo] (j >= hi) (j = j - 1) : yield j
		]] definingEnv
	return : syntax-rules 
		`[range @low @high] : begin [use 'upto'] `[@t1 @low @high]
		`[range @low till @high] : begin [use 'uptill'] `[@t2 @low @high]
		`[range @low downto @high] : begin [use 'downto'] `[@t3 @low @high]
		`[range @low downtill @high] : begin [use 'downtill'] `[@t4 @low @high]
		otherwise : throw : new FormInvalidError form "Invalid form about [range]"
define-macro foreach : syntax-rules 
	`[foreach [@varid @range] @body] {'.syntactic-closure' `[foreach @[formOf varid] @[formOf range] @[formOf body]] env}
	`[foreach @varid [range @low @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] < @hi) (@[formOf varid] = @[formOf varid] + 1) : begin @body
		]
	`[foreach @varid [range @low till @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] <= @hi) (@[formOf varid] = @[formOf varid] + 1) : begin @body
		]
	`[foreach @varid [range @low downto @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] > @hi) (@[formOf varid] = @[formOf varid] - 1) : begin @body
		]
	`[foreach @varid [range @low downtill @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] >= @hi) (@[formOf varid] = @[formOf varid] - 1) : begin @body
		]
	`[foreach @varid [items-of @list] @body] ([env.macros.get "items-of"] === [definingEnv.macros.get "items-of"]): begin 
		local tR [env.newt]
		local tN [env.newt]
		local t  [env.newt]
		return `[begin \\
			local @tR @list
			local @tN @tR.length
			local @t 0
			while (@t < @tN) : begin 
				begin @{'.syntactic-closure' `[local @[formOf varid] @tR.(@t)] env}
				begin @body
				@t = @t + 1
		]
	`[foreach @varid @range @body] : begin 
		local tR [env.newt]
		local t  [env.newt]
		return `[begin \\
			local @tR : @range.(@[externEnv.use 'Symbol'].iterator)
			local @t nothing
			while (! [set @t [@tR.next]].done) : begin 
				begin @{'.syntactic-closure' `[local @[formOf varid] @t.value] env}
				begin @body
		]
	
	otherwise : the-form-is-invalid "Invalid [foreach] Construction."

define-macro extern : syntax-rules
	`[extern @_id] [atom _id] : let [id : formOf _id] : begin
		externEnv.declare id
		return : dirty `[local @id @[externEnv.use id]]
	
	otherwise : the-form-is-invalid

define-macro import : syntax-rules
	`[import @module as @name] : dirty `[local @[formOf name] [@[externEnv.use 'require'] @module]]
	`[import @slot from @module] [atom slot] : dirty `[local @[formOf slot] [@[externEnv.use 'require'] @module].default]
	`[import @patterns from @module] : dirty `[local [object @::[formOf patterns]] [@[externEnv.use 'require'] @module]]
	`[import @module] : dirty `[@[externEnv.use 'require'] @module]
	
	otherwise : the-form-is-invalid

define-macro export : syntax-rules
	# Declaration exports, variable and function
	`[export : @(`define||`local) @slot @val] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local @[formOf slot] @[formOf val]]]]
	`[export : @(`define||`local) [@slot @::pars] @body] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local [@[formOf slot] @::[pars.map formOf]] @[formOf body]]]]
	`[export : @(`define||`local) @modifer @slot @val] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local @[formOf slot] @[formOf val]]]]
	`[export : @(`define||`local) @modifer [@slot @::pars] @body] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local @modifer [@[formOf slot] @::[pars.map formOf]] @[formOf body]]]]
	
	# Direct exports
	`[export all @content] `[begin \\
		local xs @[externEnv.use 'module'].exports
		set @[externEnv.use 'module'].exports @[dirty : formOf content]
		foreach [s : items-of : Object.keys xs] : set @[externEnv.use 'module'].exports.(s) xs.(s)
	]
	`[export @content as @slot] [atom slot] `[set @[externEnv.use 'exports'].(@{".quote" [formOf slot]}) @[dirty : formOf content]]
	`[export as @slot @content] [atom slot] `[set @[externEnv.use 'exports'].(@{".quote" [formOf slot]}) @[dirty : formOf content]]
	`[export @slot] [atom slot] `[set @[externEnv.use 'exports'].(@{".quote" [formOf slot]}) @slot]
	
	otherwise : the-form-is-invalid

# The mighty [class] macro implements OOP operations
define-macro class : syntax-rules
	`[class @typename @::_terms] [atom typename] : begin
		local terms : _terms.map formOf
		local Inherits null
		local ctorparams `[]
		local ctorbody `[begin]
		
		local publicTerms {}
		local privateTerms {}
		local protectedTerms {}
		local staticTerms {}
		local accessorAssignments {.}
		
		define [wrapPublicMethodBody name body] `[begin \\
			define-macro super : syntax-rules
				`[super @::args] `[(Super.prototype.(@2*{".quote" name})).call @[dirty `this] @::args]
			* @body
		]
		define [wrapPublicAccrssorBody name body] `[begin \\
			define-macro super : syntax-rules
				`[super] : let [t : env.newt] `[begin \\
					set t Super.prototype
					while (t && ![@[externEnv.use 'Object'].getOwnPropertyDescriptor t @2*{".quote" name}]) : set t [@[externEnv.use 'Object'].getPrototypeOf t]
					[@[externEnv.use 'Object'].getOwnPropertyDescriptor t @2*{".quote" name}].get.call @[dirty `this]
				]
				`[super @value] : let [t : env.newt] `[begin \\
					set t Super.prototype
					while (t && ![@[externEnv.use 'Object'].getOwnPropertyDescriptor t @2*{".quote" name}]) : set t [@[externEnv.use 'Object'].getPrototypeOf t]
					[@[externEnv.use 'Object'].getOwnPropertyDescriptor t @2*{".quote" name}].set.call @[dirty `this] @value
				]
			* @body
		]
		define [wrapProtectedMethodBody name body] `[begin \\
			define-macro super : syntax-rules
				`[super @::args] `[(Super.prototype.(Super.protectedTerms.(@2*{".quote" name}))).call @[dirty `this] @::args]
			* @body
		]
		
		define [handleTerm term] : match term
			# Inheritance term
			`[inherits @Super] : set Inherits Super
			
			# Public term
			# constructor
			`[public [new @::params] @body] : begin
				set ctorparams params
				set ctorbody `[begin @body [return nothing]]
			# property
			`[public get @name @body] [atom name] : begin
				if [not accessorAssignments.(name)] : set accessorAssignments.(name) {.get `nothing .set `nothing}
				set accessorAssignments.(name).get `[lambda [] @[wrapPublicAccrssorBody name body]]
			`[public get @name] [atom name] : handleTerm `[public get @name [private @name]]
			`[public set @name @value @body] [atom name] : begin
				if [not accessorAssignments.(name)] : set accessorAssignments.(name) {.get `nothing .set `nothing}
				set accessorAssignments.(name).set `[lambda [@value] @[wrapPublicAccrssorBody name body]]
			`[public set @name] [atom name] : handleTerm `[public set @name value : set [private @name] value]
			# method
			`[public [@name @::params] @body] [atom name] : begin
				publicTerms.push {`(Type.prototype.(@{".quote" name})) `[lambda @params @[wrapPublicMethodBody name body]]}
			# proto value
			`[public @name @val] [atom name] : begin
				publicTerms.push {`(Type.prototype.(@{".quote" name})) val}

			# Private term, use symbols
			`[private @name] [atom name] : privateTerms.push {name `nothing}
			`[private @name @val] [atom name] : privateTerms.push {name val}
			`[private [@name @::params] @body] [atom name] : privateTerms.push {name `[function @params @body]}
			
			# Protected term, use symbols
			`[protected @name] [atom name] : protectedTerms.push {name `nothing}
			`[protected @name @val] [atom name] : protectedTerms.push {name val}
			`[protected [@name @::params] @body] [atom name] : protectedTerms.push {name `[function @params @[wrapProtectedMethodBody name body]]}
			
			# Static terms
			`[static @name] [atom name] : staticTerms.push {name `nothing}
			`[static @name @val] [atom name] : staticTerms.push {name val}
			`[static [@name @::params] @body] [atom name] : staticTerms.push {name `[function @params @body]}

		foreach [term terms] : handleTerm term
		
		return : dirty `[begin \\
			define @typename : [function [Super] : begin \\
				define-macro public : begin
					local f : syntax-rules
						`[public @name] [atom name] : dirty `(this.(@{".quote" [formOf name]}))
					set coinit.initFn : lambda [m] : begin
						set m.toPattern : lambda [form env w] : match form
							`[public @name] [atom name] : object
								whether : lambda [t] `true
								assign : lambda [t locally] : ex `[set this.(@{".quote" name}) @t] env
					*f
				define-macro private : begin
					local f : syntax-rules
						`[private @name] [atom name] : dirty `(this.(@[definingEnv.use ("__private_" + [formOf name])]))
					set coinit.initFn : lambda [m] : begin
						set m.toPattern : lambda [form env w] : match form
							`[private @name] [atom name] : object
								whether : lambda [t] `true
								assign : lambda [t locally] : ex `[set this.(@[definingEnv.use ("__private_" + name)]) @t] env
					*f
				define-macro protected : begin
					local f : syntax-rules
						`[protected @name] [atom name] : dirty `(this.(@[definingEnv.use 'protectedTerms'].(@{".quote" [formOf name]})))
					set coinit.initFn : lambda [m] : begin
						set m.toPattern : lambda [form env w] : match form
							`[protected @name] [atom name] : object
								whether : lambda [t] `true
								assign : lambda [t locally] : ex `[set (this.(@[definingEnv.use 'protectedTerms'].(@{".quote" name}))) @t] env
					*f

				# constructor
				local Type [function @ctorparams : begin \\
					define-macro super : syntax-rules
						`[super @::args] `[Super.call @[dirty `this] @::args]
					* @ctorbody
				]
				
				# inheritance
				* @[if Inherits `[set Type.prototype [@[externEnv.use 'Object'].create Super.prototype]] `nothing]
				
				extern Symbol
				
				[lambda [] : begin \\
					# private terms
					begin @::[privateTerms.map : t -> : begin \\
						local {name val} t
						return `[begin \\
							local @('__private_' + name) [Symbol]
							set Type.prototype.(@('__private_' + name)) @val
						]
					]
					
					# protected terms
					set Type.protectedTerms : local protectedTerms : @[externEnv.use 'Object'].create (Super.protectedTerms || null)
					begin @::[protectedTerms.map : t -> : begin \\
						local {name val} t
						return `[begin \\
							if [not protectedTerms.(@{".quote" name})] : set protectedTerms.(@{".quote" name}) [Symbol]
							set Type.prototype.(protectedTerms.(@{".quote" name})) @val
						]
					]
					
					# method defs
					begin @::[publicTerms.map : function [t] : begin [local {name val} t] `[set @name @val]]
					
					# accessor defs
					begin @::[[Object.keys accessorAssignments].map : key -> : begin \\
						return `[@[externEnv.use 'Object'].defineProperty Type.prototype @{".quote" key} {
							.get @(accessorAssignments.(key).get)
							.set @(accessorAssignments.(key).set)
						}]
					]
					
					# static terms
					begin @::[staticTerms.map : function [t] : begin [local {name val} t] `[set Type.(@{".quote" name}) @val]]
					
					return nothing
				].call Type.prototype
				return Type
			] @[if Inherits Inherits [externEnv.use 'Object']]
		]
	`[class [@typename @::_params] @::_terms] : begin
		local params : _params.map formOf
		local terms : _terms.map formOf
		local arity {'.quote' params.length}
		return : dirty `[define @typename : [function [] [begin \\
			extern Map
			local cache : new Map
			define [GenericType @::params] : begin
				local pivot cache
				for [local j 0] (j < @arity) [inc j] : begin
					if [pivot.has arguments.(j)] : then
						set pivot [pivot.get arguments.(j)]
					: else
						if (j < @arity - 1) : then
							local m [new Map]
						: else
							local m : [lambda [@::params] [class _r @::terms]].apply null arguments
						
						pivot.set arguments.(j) m
						set pivot m
				return pivot
			return GenericType
		]]]
	
	otherwise : the-form-is-invalid