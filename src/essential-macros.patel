define-macro syntax-rules : lambda [form env] : macro-match form env 
	`[syntax-rules @::patterns] {'.syntactic-closure' `[lambda [form env] [begin
		[local [dirty s] {'.syntactic-closure' s env}] 
		[macro-match form env @::[patterns.map formOf]]]] env}
define-macro its : syntax-rules 
	`[its @property] : return `[let [t @property] [lambda [x] x.(t)]]
define-macro call-its : syntax-rules 
	`[call-its @property] : return `[let [t @property] [lambda [x] [x.(t)]]]
	`[call-its @property @::args] : return `[let [t @property] [a {@::args}] [lambda [x] [x.(t).apply x a]]]
define-macro getAllKeys : begin 
	local exoticAST {.type "FunctionExpression" .id null .params {{.type "Identifier" .name "o"}} .defaults {} .body {.type "BlockStatement" .body {{.type "VariableDeclaration" .declarations {{.type "VariableDeclarator" .id {.type "Identifier" .name "a"} .init {.type "ArrayExpression" .elements {}}}} .kind "var"} { .type "ForInStatement" .left {.type "VariableDeclaration" .declarations {{.type "VariableDeclarator" .id {.type "Identifier" .name "k"} .init null}} .kind "var"} .right {.type "Identifier" .name "o"} .body {.type "BlockStatement" .body {{.type "ExpressionStatement" .expression {.type "CallExpression" .callee { .type "MemberExpression" .computed false .object {.type "Identifier" .name "a"} .property {.type "Identifier" .name "push"} } .arguments {{.type "Identifier" .name "k"}}}}}} .each false } {.type "ReturnStatement" .argument {.type "Identifier" .name "a"}}}} .rest null .generator false .expression false }
	local t : definingEnv.newt
	#local coinitStatement : ex `[set @t @{".preserve" {".exotic" exoticAST}}] definingEnv
	set ijp {".begin"}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	define [used] : begin
		if [not ijp.1] : set ijp.1 : ex `[set @t @{".preserve" {".exotic" exoticAST}}] definingEnv

	local f : syntax-rules 
		`[getAllKeys] `{}
		`[getAllKeys @obj] : begin [used] `[@t @obj]
		`[getAllKeys @obj @::unused] : begin [used] `[@t @obj]
	set [f.invokeAsAtom] : begin [used] t
	return f

define-macro items-of : begin
	set ijp {".begin" nothing nothing nothing nothing}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	local t1 : definingEnv.newt
	define [use id] : match id
		'items-of' : if [not ijp.1] : set ijp.1 : ex `[set @t1 [lambda [t] [begin
			[local n t.length]
			[for [local i 0] (i < n) (i = i + 1) [yield t.(i)]]
		]]] definingEnv
	return : syntax-rules 
		`[items-of @obj] : begin [use 'items-of'] `[@t1 @obj]
		otherwise : throw : new FormInvalidError form "Invalid form about [items-of]"
define-macro pairs-of : begin
	set ijp {".begin" nothing nothing nothing nothing}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	define [use id] : match id
		'pairs-of-eigen' : if [not ijp.1] : begin
			local t : definingEnv.newt
			set ijp.1 : ex `[set @t [lambda [t] [begin \\
				if (t <@ Array) : then
					local n t.length
					for [local i 0] (i < n) (i = i + 1) : yield { i t.(i) }
				: else
					local a : Object.keys t
					local n a.length
					for [local i 0] (i < n) (i = i + 1) : yield { a.(i) t.(a.(i)) }
			]]] definingEnv
			return t
		'pairs-of-all' : if [not ijp.2] : begin
			local t : definingEnv.newt
			set ijp.2 : ex `[set @t [lambda [t] [begin \\
				local a : getAllKeys t
				local n a.length
				for [local i 0] (i < n) (i = i + 1) : yield { a.(i) t.(a.(i)) }
			]]] definingEnv
			return t
	return : syntax-rules 
		`[pairs-of @obj] : begin `[@[use 'pairs-of-eigen'] @obj]
		`[pairs-of all @obj] : begin `[@[use 'pairs-of-all'] @obj]
		otherwise : throw : new FormInvalidError form "Invalid form about [pairs-of]"
define-macro range : begin
	set ijp {".begin" nothing nothing nothing nothing}
	set coinit.injectForm `[begin @{".preserve" ijp}]
	local t1 : definingEnv.newt
	local t2 : definingEnv.newt
	local t3 : definingEnv.newt
	local t4 : definingEnv.newt
	define [use id] : match id
		'upto' : if [not ijp.1] : set ijp.1 : ex `[set @t1 [lambda [lo hi] : begin \\
			for [local j lo] (j < hi) (j = j + 1) : yield j
		]] definingEnv
		'uptill' : if [not ijp.2] : set ijp.2 : ex `[set @t2 [lambda [lo hi] : begin \\
			for [local j lo] (j <= hi) (j = j + 1) : yield j
		]] definingEnv
		'downto' : if [not ijp.3] : set ijp.3 : ex `[set @t3 [lambda [lo hi] : begin \\
			for [local j lo] (j > hi) (j = j - 1) : yield j
		]] definingEnv
		'downtill' : if [not ijp.4] : set ijp.4 : ex `[set @t4 [lambda [lo hi] : begin \\
			for [local j lo] (j >= hi) (j = j - 1) : yield j
		]] definingEnv
	return : syntax-rules 
		`[range @low @high] : begin [use 'upto'] `[@t1 @low @high]
		`[range @low till @high] : begin [use 'uptill'] `[@t2 @low @high]
		`[range @low downto @high] : begin [use 'downto'] `[@t3 @low @high]
		`[range @low downtill @high] : begin [use 'downtill'] `[@t4 @low @high]
		otherwise : throw : new FormInvalidError form "Invalid form about [range]"
define-macro foreach : syntax-rules 
	`[foreach [@varid @range] @body] {'.syntactic-closure' `[foreach @[formOf varid] @[formOf range] @[formOf body]] env}
	`[foreach @varid [range @low @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] < @hi) (@[formOf varid] = @[formOf varid] + 1) : begin @body
		]
	`[foreach @varid [range @low till @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] <= @hi) (@[formOf varid] = @[formOf varid] + 1) : begin @body
		]
	`[foreach @varid [range @low downto @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] > @hi) (@[formOf varid] = @[formOf varid] - 1) : begin @body
		]
	`[foreach @varid [range @low downtill @high] @body] ([env.macros.get "range"] === [definingEnv.macros.get "range"]): begin 
		local lo [env.newt]
		local hi [env.newt]
		return `[begin \\
			local @lo @low
			local @hi @high
			for @{'.syntactic-closure' `[local @[formOf varid] @lo] env} (@[formOf varid] >= @hi) (@[formOf varid] = @[formOf varid] - 1) : begin @body
		]
	`[foreach @varid [items-of @list] @body] ([env.macros.get "items-of"] === [definingEnv.macros.get "items-of"]): begin 
		local tR [env.newt]
		local tN [env.newt]
		local t  [env.newt]
		return `[begin \\
			local @tR @list
			local @tN @tR.length
			local @t 0
			while (@t < @tN) : begin 
				begin @{'.syntactic-closure' `[local @[formOf varid] @tR.(@t)] env}
				begin @body
				@t = @t + 1
		]
	`[foreach @varid @range @body] : begin 
		local tR [env.newt]
		local t  [env.newt]
		return `[begin \\
			local @tR : @range.(@[externEnv.use 'Symbol'].iterator)
			local @t nothing
			while (! [set @t [@tR.next]].done) : begin 
				begin @{'.syntactic-closure' `[local @[formOf varid] @t.value] env}
				begin @body
		]

define-macro extern : syntax-rules
	`[extern @_id] [atom _id] : let [id : formOf _id] : begin
		externEnv.declare id
		return : dirty `[local @id @[externEnv.use id]]
define-macro import : syntax-rules
	`[import @module as @name] : dirty `[local @[formOf name] [@[externEnv.use 'require'] @module]]
	`[import @slot from @module] [atom slot] : dirty `[local @[formOf slot] [@[externEnv.use 'require'] @module].default]
	`[import @patterns from @module] : dirty `[local [object @::[formOf patterns]] [@[externEnv.use 'require'] @module]]
	`[import @module] : dirty `[@[externEnv.use 'require'] @module]

define-macro export : syntax-rules
	# Declaration exports, variable and function
	`[export : @(`define||`local) @slot @val] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local @[formOf slot] @[formOf val]]]]
	`[export : @(`define||`local) [@slot @::pars] @body] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local [@[formOf slot] @::[pars.map formOf]] @[formOf body]]]]
	`[export : @(`define||`local) @modifer @slot @val] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local @[formOf slot] @[formOf val]]]]
	`[export : @(`define||`local) @modifer [@slot @::pars] @body] [atom slot] `[set
		@[externEnv.use 'exports'].(@{".quote" [formOf slot]})
		@[dirty `[local @modifer [@[formOf slot] @::[pars.map formOf]] @[formOf body]]]]
	
	# Direct exports
	`[export all @content] `[begin \\
		local xs @[externEnv.use 'module'].exports
		set @[externEnv.use 'module'].exports @[dirty : formOf content]
		foreach [s : items-of : Object.keys xs] : set @[externEnv.use 'module'].exports.(s) xs.(s)
	]
	`[export @content as @slot] [atom slot] `[set @[externEnv.use 'exports'].(@{".quote" [formOf slot]}) @[dirty : formOf content]]
	`[export as @slot @content] [atom slot] `[set @[externEnv.use 'exports'].(@{".quote" [formOf slot]}) @[dirty : formOf content]]
	`[export @slot] [atom slot] `[set @[externEnv.use 'exports'].(@{".quote" [formOf slot]}) @slot]

define-macro set-operator-info : syntax-rules
	`[set-operator-info @{".quote" operator} @{".quote" priority} @{".quote" associvity}] : begin
		env.operatorInfo.put [formOf operator] {
			.priority [formOf priority]
			.associvity [formOf associvity]
		}
		return nothing
	`[set-operator-info @{".quote" operator} @{".quote" priority}] : begin
		env.operatorInfo.put [formOf operator] {
			.priority [formOf priority]
			.associvity "never"
		}
		return nothing

define-macro define-operator : syntax-rules
	`[define-operator @{".quote" operator} @{".quote" priority} @{".quote" associvity} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]} @{".quote" [formOf associvity]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator @{".quote" operator} @{".quote" priority} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator infix @{".quote" operator} @{".quote" priority} @{".quote" associvity} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]} @{".quote" [formOf associvity]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator infix @{".quote" operator} @{".quote" priority} @body] : dirty `[begin \\
		set-operator-info @{".quote" [formOf operator]} @{".quote" [formOf priority]}
		define-macro @{".quote" [formOf operator]} @[formOf body]
	]
	`[define-operator prefix @{".quote" operator} @body] : dirty `[begin \\
		define-macro @{".quote" (".prefix." + [formOf operator])} @[formOf body]
	]