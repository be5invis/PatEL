define patrisika [require "patrisika"]
define [atom x] [[typeof x] == "string"]
define [prim x] [[atom x] && x !== "&" && x !== "&!" && [x`0 === "." || [[regex "^\W+"].test x]]]
define Scope [require "patrisika"].Scope
define escodegen [require "escodegen"]
define util [require "util"]
define ex [require "./ex"].ex
define deQuasiquote [require "./ex"].deQuasiquote

define [FormInvalidError form reason] : begin {
	set this.reason reason
	set this.message reason
	set this.relatedForm form
	if [form && form.begins >= 0 && form.ends >= 0] : begin {
		set this.begins form.begins
		set this.ends form.ends
		inc this.message by ["\nAround (" + this.begins + " -- " + this.ends + ")"]
	}
	return null
}
set FormInvalidError.prototype : Object.create Error.prototype

define [wrapForSyntacticClosure fn] : lambda [x] : match x {
	(".syntactic-closure" c e)	: fn c
	otherwise                 	: fn x
}

# This file defines built-in macros of PatEL
define [Create] : begin {
	local externs [patrisika.DefaultExterns]
	set [externs.castName name] name
	externs.declare "require"
	externs.declare "exports"
	externs.declare "process"
	externs.declare "module"
	externs.declare "Error"
	
	define [operatorRename op] : lambda [form env] [ex (op :: [form.slice 1]) env]
	define [reportInvalid form reason] : throw : new FormInvalidError form reason

	#externs.macros.put "lambda" : operatorRename ".lambda"
	externs.macros.put "begin" : operatorRename ".begin"
	externs.macros.put "then" : operatorRename ".begin"
	externs.macros.put "else" : operatorRename ".begin"
	#externs.macros.put "if" : operatorRename ".if"
	externs.macros.put "while" : operatorRename ".while"
	externs.macros.put "try" : operatorRename ".try"
	externs.macros.put "is" : operatorRename ".is"
	externs.macros.put "<@" :operatorRename ".is"
	externs.macros.put "new" : operatorRename ".new"
	externs.macros.put "this" : operatorRename ".thisp"
	externs.macros.put "arguments" : operatorRename ".argsp"
	externs.macros.put "and" : operatorRename "&&"
	externs.macros.put "or" : operatorRename "||"
	externs.macros.put "not" : operatorRename "!"
	externs.macros.put "return" : operatorRename ".return"
	externs.macros.put "yield" : operatorRename ".yield"
	externs.macros.put "throw" : operatorRename ".throw"
	externs.macros.put "list" : operatorRename ".list"
	externs.macros.put "typeof" : operatorRename ".typeof"
	externs.macros.put "quasiquote" : operatorRename ".quasiquote"
	externs.macros.put "syntax" : operatorRename ".quasiquote"

	externs.macros.put "lambda" : lambda [form env] : match form {
		(car parameters body)	: ex ('.lambda' parameters body) env
		(car body)           	: ex ('.lambda' () body) env
		(car)                	: ex ('.lambda' () ('.unit')) body
		otherwise            	: reportInvalid otherwise "Invalid Lambda Formation"
	}
	externs.macros.put "function" : externs.macros.get "lambda"

	externs.macros.put "if" : lambda [form env] : match form {
		("if" test consequent)                                    	: ex ('.if' test consequent) env
		("if" test consequent alternate)                          	: ex ('.if' test consequent alternate) env
		("if" test ('then' :: consequents))                       	: ex ('.if' test ('.begin' :: consequents)) env
		("if" test ('then' :: consequents) ('else' :: alternates))	: ex ('.if' test ('.begin' :: consequents) ('.begin' :: alternates)) env
		otherwise                                                 	: reportInvalid otherwise "Invalid Conditional Form"
	}

	externs.macros.put ".conslist" : lambda [form env] {
		return (
			("." [ex (".list" :: [form.slice 1 [-1]]) env] (".quote" "concat"))
			[ex form`[form.length - 1] env]
		)
	}

	externs.macros.put "let" : lambda [form env] : begin {
		local pairs [form.slice 1 [0 - 1]]
		local args ()
		local paras ()
		for [local j 0] [j < pairs.length] [inc j] : match pairs`j {
			(arg param :: useless)	: begin { args.push arg; paras.push param }
			(arg param)           	: begin { args.push arg; paras.push param }
			(arg) [atom arg]      	: begin { args.push arg; paras.push [env.use arg] }
		}
		ex (".beta" args form`[form.length - 1] :: paras) env
	}

	externs.macros.put "object" : lambda [form env] : begin {
		local pairs : [form.slice 1].map : lambda [pair] : match pair {
			(property value :: useless)	: return (property [ex value env])
			(property value)           	: return (property [ex value env])
			(property) [atom property] 	: return (property [env.use property])
		}
		return (".hash" :: pairs)
	}

	externs.macros.put "piecewise" : lambda [form env] : match form {
		("piecewise" :: pairs) : begin {
			local f (".unit")
			for [local j [pairs.length - 1]] [j >= 0] [set j [j - 1]] {
				set f (".if" [ex pairs`j`0 env] [ex pairs`j`1 env] f)
			}
			return f
		}
	}

	define [AssignWithMod left right mod env locallyQ] : match left {
			("local" a)       	: AssignWithMod a left right mod env true
			(".local" a)      	: AssignWithMod a left right mod env true
			(".list" :: items)	: Assign left (mod right) env locallyQ
			(".hash" :: items)	: Assign left (mod right) env locallyQ
	
			(callee :: paras) : piecewise {
				[prim callee] (".set" [ex left env] [ex (mod right) env])
				[atom callee] : piecewise {
					locallyQ (".set" 
						[ex (".local" callee) env] 
						[ex (mod (".lambda" (::paras) right)) env])
					true (".set" 
						[ex callee env]
						[ex (mod (".lambda" (::paras) right)) env])
				}
				true (".set" [ex callee env] [ex (mod (".lambda" (::paras) right)) env])
			}
	
			any : Assign ex left (mod right) env locallyQ
	}
	define [Assign left right env locallyQ] : match left {
		id [atom id] : piecewise {
			locallyQ (".set" [ex (".local" id) env] [ex right env])
			true     (".set" [ex left env] [ex right env])
		}

		("local" a) : Assign a right env true
		(".local" a) : Assign a right env true

		(".list" :: items) : begin {
			local t [env.newt]
			local assignments (".begin" (".set" t [ex right env]))
			for [local j 0] [j < items.length] [inc j] {
				assignments.push : Assign items`j ("." t (".quote" j)) env locallyQ
			}
			assignments.push t
			return assignments
		}

		(".hash" :: items) : begin {
			local t [env.newt]
			local assignments (".begin" (".set" t [ex right env]))
			for [local j 0] [j < items.length] [inc j] {
				assignments.push : Assign items`j`1 ("." t items`j`0)  env locallyQ
			}
			assignments.push t
			return assignments
		}

		(callee :: paras) : piecewise {
			[prim callee] (".set" [ex left env] [ex right env])
			[atom callee] : piecewise {
				locallyQ (".set" 
					[ex (".local" callee) env] 
					[ex (".lambda" (::paras) right) env])
				true (".set" 
					[ex callee env]
					[ex (".lambda" (::paras) right) env])
			}
			true (".set" [ex callee env] [ex (".lambda" (::paras) right) env])
		}
		any : throw [new FormInvalidError left "Invalid Assignment Left-hand Side"]
	}

	externs.macros.put "define" : lambda [form env] : match form {
		(op modifer left right) : AssignWithMod left right modifer env true
		(op left right) : Assign left right env true
		(op left) [atom left] : return (".local" left)
		any : throw [new FormInvalidError any "Invalid Assignment"]
	}
	externs.macros.put "local" : externs.macros.get "define"
	externs.macros.put "set" : lambda [form env] : match form {
		(op left right) : Assign left right env false
		any : throw [new FormInvalidError any "Invalid Assignment"]
	}

	externs.macros.put "inc" : lambda [form env] : match form {
		(op id)           	[Assign id ("+" id (".quote" 1)) env false]
		(op id shift)     	[Assign id ("+" id shift) env false]
		(op id "by" shift)	[Assign id ("+" id shift) env false]
	}
	externs.macros.put "dec" : lambda [form env] : match form {
		(op id)           	[Assign id ("-" id (".quote" 1)) env false]
		(op id shift)     	[Assign id ("-" id shift) env false]
		(op id "by" shift)	[Assign id ("-" id shift) env false]
	}

	externs.macros.put "for" : lambda [form env] : match form {
		("for" init test step body) (".begin"
			[ex init env]
			(".while" [ex test env] (".begin" [ex body env] [ex step env])))
	}

	externs.macros.put "foreach" : lambda [form env] : match form {
		("foreach" varid range body) : begin {
			local tR [env.newt]
			local t  [env.newt]
			return (".begin"
				(".set" tR [ex range env])
				(".while" 
					("!" ("." (".set" t (("." tR (".quote" "next")))) (".quote" "done"))) 
					(".begin"
						[Assign varid ("." t (".quote" "value")) env false]
						[ex body env])))
		}
	}

	externs.macros.put "this" (".thisp")
	externs.macros.put "arguments" (".argsp")
	externs.macros.put "nothing" (".unit")
	externs.macros.put "undefined" (".unit")
	externs.macros.put "null" (".quote" null)
	externs.macros.put "true" (".quote" true)
	externs.macros.put "false" (".quote" false)

	define [boole x] [not [not x]]
	externs.macros.put "match" : lambda [form env wrapper] : begin {
		local pairs [form.slice 2]
		local t [env.newt]

		define [matchQ pattern] : match pattern {
			id [atom id] : object {
				whether : lambda [x] null
				assign : lambda [x flag] (".set" [ex (".local" pattern) env] [if [wrapper && !flag] (wrapper x) x])
			}
			(".quote" x) : object {
				whether : lambda [x] ("===" [ex pattern env] x)
				assign  : lambda [x flag] (".unit")
			}
			("." :: whatever) : object {
				whether : lambda [x] null
				assign : lambda [x flag] (".set" [ex pattern env] [if [wrapper && !flag] (wrapper x) x])
			}
			(".list" :: subpatterns) : begin {
				local ms : subpatterns.map matchQ
				return : object {
					whether : lambda [x] [
						("&&" 
							(".is" x [externs.use "Array"]) 
							("===" ("." x (".quote" "length")) (".quote" ms.length)) 
							:: [ms.map [lambda [p j] 
								[p.whether ("." x (".quote" j))]]]
						).filter boole]
					assign : lambda [x flag] (".begin" :: [ms.map [lambda [p j] 
						[p.assign ("." x (".quote" j)) flag]]] )
				}
			}
			(".conslist" :: subpatterns) : begin {
				local ms : [pattern.slice 1 [0 - 1]].map matchQ
				local final : matchQ pattern`[pattern.length - 1]
				return : object {
					whether : lambda [x] [
						("&&" 
							(".is" x [externs.use "Array"]) 
							(">=" ("." x (".quote" "length")) (".quote" ms.length)) 
							:: [
								[ms.map [lambda [p j] 
									[p.whether ("." x (".quote" j))]]].concat
								[list [final.whether (("." x (".quote" "slice")) (".quote" j))]]]
						).filter boole]
					assign : lambda [x flag] [(".begin"
						:: [ms.map [lambda [p j] 
							[p.assign ("." x (".quote" j))]]] 
						).concat [list [final.assign 
							[if [wrapper && !flag]
								(("." (("." x (".quote" "slice")) (".quote" ms.length)) (".quote" "map")) wrapper)
								(("." x (".quote" "slice")) (".quote" ms.length))] true]]]
				}
			}
			(".quasiquote" :: subpatterns) : begin {
				matchQ [deQuasiquote pattern`1 0]
			}
			(callee :: subpatterns) : begin {
				local ms : subpatterns.map matchQ
				local t : env.newt
				return : object {
					whether : lambda [x] [
						("&&" 
							(".set" t 
								(("." [ex callee env] (".quote" "unapply"))
									x (".quote" ms.length)))
							:: [ms.map [lambda [p j] 
								[p.whether ("." t (".quote" j))]]]
						).filter boole]
					assign : lambda [x flag] (".begin" :: [ms.map [lambda [p j]
						[p.assign ("." t (".quote" j)) flag]]] )
				}
			}
		}

		local f (".unit")
		for [local j [pairs.length - 1]] [j >= 0] [dec j] : set f : match pairs`j {
			(pattern body) : begin {
				local pat : matchQ pattern
				local cond : pat.whether t
				piecewise {
					cond (".if" cond (".begin" [pat.assign t] [ex body env]) f)
					true (".begin" [pat.assign t] [ex body env])
				}
			}
			(pattern guard body) : begin {
				local pat : matchQ pattern
				local cond : pat.whether t
				piecewise {
					cond : begin {
						local tc : env.newt
						* (".begin" 
							(".set" tc (".quote" false)) 
							(".if" cond (".begin" 
								[pat.assign t]
								(".if" [ex guard env] 
									(".set" tc (".quote" true)) 
									(".set" tc (".quote" false)))))
							(".if" tc [ex body env] f))
					}
					true (".begin" 
						[pat.assign t] 
						(".if" [ex guard env] [ex body env] f ))
				}
			}
			any f
		}
		return (".begin" (".set" t [ex form`1 env]) f)
	}

	externs.macros.put "regex" : lambda [form env] : match form {
		("regex" (".quote" s)) (".quote" [new RegExp s])
		("regex" (".quote" s) (".quote" flag)) (".quote" [new RegExp s flag])
		("regex" :: args) (".new" [externs.use "RegExp"] :: args)
	}

	externs.macros.put "define-macro" : lambda [form env] : match form {
		(op name body) [atom name] : begin {
			local ds [new Scope env]
			ds.declare "atom" true
			ds.declare "prim" true
			ds.declare "formOf" true
			ds.declare "scopeOf" true
			ds.declare "defineScope" true
			local macroG : new Function {
				ds.castName 'atom'
				ds.castName 'prim'
				ds.castName 'formOf'
				ds.castName 'defineScope'
				escodegen.generate : patrisika.generate (".return" [ex body ds]) ds [lambda [form] (".return" form)]
			}
			local macroFn [macroG [wrapForSyntacticClosure atom] [wrapForSyntacticClosure prim] [lambda [x] x`1] [lambda [x] x`2] ds]
			env.macros.put name : lambda [c e] : begin {
				local result [macroFn c e]
				return [ex result [new Scope env]]
			}
			return (".unit")
		}
		otherwise (".unit")
	}

	externs.macros.put "macro-match" : lambda [form env] : match form {
		("macro-match" c e :: patterns) : begin {
			local t [env.newt]
			local tx [env.newt]
			local tw [env.newt]
			return (".begin"
				(".set" t e)
				(".set" tw (".lambda" (tx) (".return" (".list" (".quote" ".syntactic-closure") tx t))))
				[[externs.macros.get "match"] ("match" c :: patterns) env tw])
		}
		otherwise (".unit")
	}

	[externs.macros.get "define-macro"] ('define-macro' 'syntax-rules' ( 'lambda' ( 'form' 'env' ) ( 'macro-match' 'form' 'env'
		( ( '.quasiquote' ( 'syntax-rules' ( '.sliceunquote' 'patterns' ) ) )
		  ( '.quasiquote' ( 'lambda' ( 'form' 'env' ) ( 'macro-match' 'form' 'env' ( '.sliceunquote' ( ( '.' 'patterns' ( '.quote' 'map' ) ) 'formOf' ) ) ) ) ) ) ) ) ) externs

	set externs.pFamily 'r'

	return externs
}

define exports.Create Create
