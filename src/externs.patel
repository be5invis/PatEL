define patrisika [require "patrisika"]
define [atom x] ([typeof x] == "string")
define [identifier x] : [atom x] && [[regex '^[A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶ-ͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԣԱ-Ֆՙա-ևא-תװ-ײء-يٮ-ٯٱ-ۓەۥ-ۦۮ-ۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴ-ߵߺऄ-हऽॐक़-ॡॱ-ॲॻ-ॿঅ-ঌএ-ঐও-নপ-রলশ-হঽৎড়-ঢ়য়-ৡৰ-ৱਅ-ਊਏ-ਐਓ-ਨਪ-ਰਲ-ਲ਼ਵ-ਸ਼ਸ-ਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલ-ળવ-હઽૐૠ-ૡଅ-ଌଏ-ଐଓ-ନପ-ରଲ-ଳଵ-ହଽଡ଼-ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கங-சஜஞ-டண-தந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘ-ౙౠ-ౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠ-ೡഅ-ഌഎ-ഐഒ-നപ-ഹഽൠ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะา-ำเ-ๆກ-ຂຄງ-ຈຊຍດ-ທນ-ຟມ-ຣລວສ-ຫອ-ະາ-ຳຽເ-ໄໆໜ-ໝༀཀ-ཇཉ-ཬྈ-ྋက-ဪဿၐ-ၕၚ-ၝၡၥ-ၦၮ-ၰၵ-ႁႎႠ-Ⴥა-ჺჼᄀ-ᅙᅟ-ᆢᆨ-ᇹሀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙶᚁ-ᚚᚠ-ᛪᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦩᧁ-ᧇᨀ-ᨖᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮ-ᮯᰀ-ᰣᱍ-ᱏᱚ-ᱽᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₔℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃ-ↄⰀ-Ⱞⰰ-ⱞⱠ-Ɐⱱ-ⱽⲀ-ⳤⴀ-ⴥⴰ-ⵥⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〆〱-〵〻-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆷㇰ-ㇿ㐀-䶵一-鿃ꀀ-ꒌꔀ-ꘌꘐ-ꘟꘪ-ꘫꙀ-ꙟꙢ-ꙮꙿ-ꚗꜗ-ꜟꜢ-ꞈꞋ-ꞌꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꤊ-ꤥꤰ-ꥆꨀ-ꨨꩀ-ꩂꩄ-ꩋ가-힣豈-鶴侮-頻並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ_$][0-9A-Z_a-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮ\u0300-ʹͶ-ͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁ\u0483-\u0487Ҋ-ԣԱ-Ֆՙա-և\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7א-תװ-ײ\u0610-\u061aء-\u065e٠-٩ٮ-ۓە-\u06dc\u06df-\u06e8\u06ea-ۼۿܐ-\u074aݍ-ޱ߀-ߵߺ\u0901-ह\u093c-\u094dॐ-\u0954क़-\u0963०-९ॱ-ॲॻ-ॿ\u0981-\u0983অ-ঌএ-ঐও-নপ-রলশ-হ\u09bc-\u09c4\u09c7-\u09c8\u09cb-ৎ\u09d7ড়-ঢ়য়-\u09e3০-ৱ\u0a01-\u0a03ਅ-ਊਏ-ਐਓ-ਨਪ-ਰਲ-ਲ਼ਵ-ਸ਼ਸ-ਹ\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51ਖ਼-ੜਫ਼੦-\u0a75\u0a81-\u0a83અ-ઍએ-ઑઓ-નપ-રલ-ળવ-હ\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acdૐૠ-\u0ae3૦-૯\u0b01-\u0b03ଅ-ଌଏ-ଐଓ-ନପ-ରଲ-ଳଵ-ହ\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57ଡ଼-ଢ଼ୟ-\u0b63୦-୯ୱ\u0b82-ஃஅ-ஊஎ-ஐஒ-கங-சஜஞ-டண-தந-பம-ஹ\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcdௐ\u0bd7௦-௯\u0c01-\u0c03అ-ఌఎ-ఐఒ-నప-ళవ-హఽ-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56ౘ-ౙౠ-\u0c63౦-౯\u0c82-\u0c83ಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6ೞೠ-\u0ce3೦-೯\u0d02-\u0d03അ-ഌഎ-ഐഒ-നപ-ഹഽ-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57ൠ-\u0d63൦-൯ൺ-ൿ\u0d82-\u0d83අ-ඖක-නඳ-රලව-ෆ\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2-\u0df3ก-\u0e3aเ-\u0e4e๐-๙ກ-ຂຄງ-ຈຊຍດ-ທນ-ຟມ-ຣລວສ-ຫອ-\u0eb9\u0ebb-ຽເ-ໄໆ\u0ec8-\u0ecd໐-໙ໜ-ໝༀ\u0f18-\u0f19༠-༩\u0f35\u0f37\u0f39\u0f3e-ཇཉ-ཬ\u0f71-\u0f84\u0f86-ྋ\u0f90-\u0f97\u0f99-\u0fbc\u0fc6က-၉ၐ-႙Ⴀ-Ⴥა-ჺჼᄀ-ᅙᅟ-ᆢᆨ-ᇹሀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ\u135fᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙶᚁ-ᚚᚠ-ᛪᜀ-ᜌᜎ-\u1714ᜠ-\u1734ᝀ-\u1753ᝠ-ᝬᝮ-ᝰ\u1772-\u1773ក-ឳ\u17b6-\u17d3ៗៜ-\u17dd០-៩\u180b-\u180d᠐-᠙ᠠ-ᡷᢀ-ᢪᤀ-ᤜ\u1920-\u192b\u1930-\u193b᥆-ᥭᥰ-ᥴᦀ-ᦩ\u19b0-\u19c9᧐-᧙ᨀ-\u1a1b\u1b00-ᭋ᭐-᭙\u1b6b-\u1b73\u1b80-\u1baaᮮ-᮹ᰀ-\u1c37᱀-᱉ᱍ-ᱽᴀ-\u1de6\u1dfe-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ‿-⁀⁔ⁱⁿₐ-ₔ\u20d0-\u20dc\u20e1\u20e5-\u20f0ℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃ-ↄⰀ-Ⱞⰰ-ⱞⱠ-Ɐⱱ-ⱽⲀ-ⳤⴀ-ⴥⴰ-ⵥⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ\u2de0-\u2dffⸯ々-〆\u302a-\u302f〱-〵〻-〼ぁ-ゖ\u3099-\u309aゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆷㇰ-ㇿ㐀-䶵一-鿃ꀀ-ꒌꔀ-ꘌꘐ-ꘫꙀ-ꙟꙢ-\ua66f\ua67c-\ua67dꙿ-ꚗꜗ-ꜟꜢ-ꞈꞋ-ꞌꟻ-\ua827ꡀ-ꡳ\ua880-\ua8c4꣐-꣙꤀-\ua92dꤰ-\ua953ꨀ-\uaa36ꩀ-\uaa4d꩐-꩙가-힣豈-鶴侮-頻並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻ\ufe00-\ufe0f\ufe20-\ufe26︳-︴﹍-﹏ﹰ-ﹴﹶ-ﻼ０-９Ａ-Ｚ＿ａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\-_@$]*$'].test x]
define [prim x] : [atom x] && ![identifier x]
define Scope [require "patrisika"].Scope
define escodegen [require "escodegen"]
define util [require "util"]
define ex [require "./ex"].ex
define deQuasiquote [require "./ex"].deQuasiquote
define opSegToRegular [require "./ex"].opSegToRegular

define FormInvalidError patrisika.FormInvalidError

define [wrapForSyntacticClosure fn] : lambda [x] : match x 
	{".syntactic-closure" c e}	: fn c
	otherwise                 	: fn x

# This file defines built-in macros of PatEL
define [Create] : begin 
	local externs [patrisika.DefaultExterns]
	set [externs.castName name] name
	externs.declare "require"
	externs.declare "exports"
	externs.declare "process"
	externs.declare "module"
	externs.declare "Error"
	
	define [operatorRename op] : lambda [form env] [ex {op :: [form.slice 1]} env]
	define [reportInvalid form reason] : throw : new FormInvalidError form reason

	#externs.macros.put "lambda" : operatorRename ".lambda"
	externs.macros.put "begin" : operatorRename ".begin"
	externs.macros.put "then" : operatorRename ".begin"
	externs.macros.put "else" : operatorRename ".begin"
	#externs.macros.put "if" : operatorRename ".if"
	externs.macros.put "while" : operatorRename ".while"
	externs.macros.put "try" : operatorRename ".try"
	externs.macros.put "is" : operatorRename ".is"
	externs.macros.put "<@" :operatorRename ".is"
	externs.macros.put "new" : operatorRename ".new"
	externs.macros.put "this" : operatorRename ".thisp"
	externs.macros.put "arguments" : operatorRename ".argsp"
	externs.macros.put "and" : operatorRename "&&"
	externs.macros.put "or" : operatorRename "||"
	externs.macros.put "not" : operatorRename "!"
	externs.macros.put "return" : operatorRename ".return"
	externs.macros.put "yield" : operatorRename ".yield"
	externs.macros.put "throw" : operatorRename ".throw"
	externs.macros.put "list" : operatorRename ".list"
	externs.macros.put "typeof" : operatorRename ".typeof"
	externs.macros.put "quasiquote" : operatorRename ".quasiquote"
	externs.macros.put "syntax" : operatorRename ".quasiquote"

	externs.macros.put "lambda" : lambda [form env] : match form 
		{car parameters body} [atom parameters]	: ex {'.lambda' {parameters} body} env
		{car parameters body}                  	: ex {'.lambda' parameters body} env
		{car body}                             	: ex {'.lambda' {} body} env
		{car}                                  	: ex {'.lambda' {} {'.unit'}} body
		otherwise                              	: reportInvalid otherwise "Invalid Lambda Formation"
	externs.macros.put "function" : externs.macros.get "lambda"
	externs.macros.put "->" : externs.macros.get "lambda"
	externs.macros.put "=>" : externs.macros.get "lambda"
	
	externs.operatorInfo.put "->" {
		.priority 900
		.associvity 'right'
	}
	externs.operatorInfo.put "=>" {
		.priority 950
		.associvity 'right'
	}

	externs.macros.put "if" : lambda [form env] : match form 
		{"if" test consequent}                                    	: ex {'.if' test consequent} env
		{"if" test consequent alternate}                          	: ex {'.if' test consequent alternate} env
		{"if" test {'then' :: consequents}}                       	: ex {'.if' test {'.begin' :: consequents}} env
		{"if" test {'then' :: consequents} {'else' :: alternates}}	: ex {'.if' test {'.begin' :: consequents} {'.begin' :: alternates}} env
		otherwise                                                 	: reportInvalid otherwise "Invalid Conditional Form"

	externs.macros.put "let" : lambda [form env] : begin 
		local pairs [form.slice 1 (0 - 1)]
		local args {}
		local paras {}
		for [local j 0] (j < pairs.length) [inc j] : match pairs.(j) 
			{arg param :: useless}	: begin 
				args.push arg; paras.push param
			{arg param}           	: begin 
				args.push arg; paras.push param
			{arg} [atom arg]      	: begin 
				args.push arg; paras.push [env.use arg]
		ex {".beta" args form.((form.length - 1)) :: paras} env

	externs.macros.put "object" : lambda [form env] : begin
		local pairs : [form.slice 1].map : lambda [pair] : match pair
			# Property initalizer, identifier
			`(@property = @value) [atom property]        : return {{".quote" property} value}
			{"=" property value}  [atom property]        : return {{".quote" property} value}
			{property value}      [atom property]        : return {{".quote" property} value}
			{property}            [atom property]        : return {{".quote" property} property}
			property              [atom property]        : return {{".quote" property} property}
			# Property initalizer, string
			`(@{".quote" property} = @value)             : return {{".quote" property} value}
			{"=" {".quote" property} value}              : return {{".quote" property} value}
			{{".quote" property} value}                  : return {{".quote" property} value}
			# Method initalizer, identifier
			`([@method @::param] = @value) [atom method] : return {{".quote" method} {".lambda" param value}}
			{"=" {method :: param} value}  [atom method] : return {{".quote" method} {".lambda" param value}}
			`[[@method @::param] @value]   [atom method] : return {{".quote" method} {".lambda" param value}}
			# TODO : Accessor initalizer
		return : ex {".xhash" :: [pairs.filter [lambda [x] x]]} env
	
	set [externs.macros.get "list"].toPattern : lambda [form env wrapper] : toPattern {".list" :: [form.slice 1]} env wrapper
	set [externs.macros.get "object"].toPattern : lambda [form env wrapper] : begin
		local pairs : [form.slice 1].map : lambda [pair] : match pair
			# Property initalizer, identifier
			`(@property = @value) [atom property]        : return {property value}
			{"=" property value}  [atom property]        : return {property value}
			{property value}      [atom property]        : return {property value}
			{property}            [atom property]        : return {property property}
			property              [atom property]        : return {property property}
			# Property initalizer, string
			`(@{".quote" property} = @value)             : return {property value}
			{"=" {".quote" property} value}              : return {property value}
			{{".quote" property} value}                  : return {property value}
			# Method initalizer, identifier
			otherwise : throw [new FormInvalidError form "Invalid Assignment Left-hand Side"]
			# TODO : Accessor initalizer
		return : toPattern {".hash" :: pairs} env wrapper

	externs.macros.put "piecewise" : lambda [form env] : match form 
		{"piecewise" :: pairs} : begin 
			local f {".unit"}
			for [local j (pairs.length - 1)] (j >= 0) [set j (j - 1)] : match pairs.(j) 
				{condition consequent} : set f {".if" [ex condition env] [ex consequent env] f}
				otherwise : throw [new FormInvalidError otherwise "Invalid Piecewise Segment"]
			return f

	define [AssignWithMod left right mod env locallyQ] : match left 
		id [atom id] : piecewise 
			locallyQ	{".set" [ex {".local" id} env] [ex {mod right} env]}
			true    	{".set" [ex left env] [ex {mod right} env]}
		{".id" id} [atom id] : piecewise 
			locallyQ	{".set" [ex {".local" id} env] [ex {mod right} env]}
			true    	{".set" [ex left env] [ex {mod right} env]}
		{".id" id e} ([atom id] && (e == env || !locallyQ)) : piecewise 
			locallyQ	{".set" [ex {".local" id} e] [ex {mod right} e]}
			true    	{".set" [ex left e] [ex {mod right} e]}
		{".id" id e} ([atom id] && e != env && locallyQ) : throw [new FormInvalidError left "Attempt to redefine non-local subform"]
		{".local" a} : AssignWithMod a right mod env true
		{".syntactic-closure" a e} (e == env || !locallyQ) : AssignWithMod a right mod env locallyQ
		{".syntactic-closure" a e} (e != env && locallyQ) : throw [new FormInvalidError left "Attempt to redefine non-local subform"]
		{".revcall" :: whatever} : AssignWithMod {:: whatever} right mod env locallyQ
		{callee :: paras} : piecewise 
			([atom callee] && [env.macros.has callee] && [env.macros.get callee].toPattern) : begin
				local pat : toPattern left env
				local t : env.newt
				return {".begin"
					{".set" t [ex {mod right} env]}
					[pat.assign t locallyQ] }
			([atom callee] && [env.macros.has callee]) : throw [new FormInvalidError left "Invalid Assignment Left-hand Side"]
			[prim callee] {".set" [ex left env] [ex {mod right} env]}
			[atom callee] : piecewise 
				locallyQ {".set" 
					[ex {".local" callee} env] 
					[ex {mod {".lambda" {::paras} right}} env]}
				true {".set" 
					[ex callee env]
					[ex {mod {".lambda" {::paras} right}} env]}
			true {".set" [ex callee env] [ex {mod {".lambda" {::paras} right}} env]}
		any : throw [new FormInvalidError left "Invalid Assignment Left-hand Side"]

	# Form [.unquote x] means exactly x
	define [Assign left right env locallyQ] : AssignWithMod left right ".unquote" env locallyQ

	externs.macros.put "define" : lambda [form env] : match form 
		`[@op @modifer @left @right]	: AssignWithMod left right modifer env true
		`[@op @left @right]         	: Assign left right env true
		`[@op @left] [atom left]    	: return {".local" left}
		any                          	: throw [new FormInvalidError any "Invalid Assignment"]
	externs.macros.put "local" : externs.macros.get "define"
	externs.macros.put "set" : lambda [form env] : match form 
		{op left right} : Assign left right env false
		any : throw [new FormInvalidError any "Invalid Assignment"]
	externs.macros.put "=" : externs.macros.get "set"

	externs.macros.put "inc" : lambda [form env] : match form 
		{op id}           	[Assign id {"+" id {".quote" 1}} env false]
		{op id shift}     	[Assign id {"+" id shift} env false]
		{op id "by" shift}	[Assign id {"+" id shift} env false]
	externs.macros.put "dec" : lambda [form env] : match form 
		{op id}           	[Assign id {"-" id {".quote" 1}} env false]
		{op id shift}     	[Assign id {"-" id shift} env false]
		{op id "by" shift}	[Assign id {"-" id shift} env false]

	externs.macros.put "for" : lambda [form env] : match form 
		{"for" init test step body} {".begin"
			[ex init env]
			{".while" [ex test env] {".begin" [ex body env] [ex step env]}}}

	externs.macros.put "this" {".thisp"}
	externs.macros.put "arguments" {".argsp"}
	externs.macros.put "nothing" {".unit"}
	externs.macros.put "undefined" {".unit"}
	externs.macros.put "null" {".quote" null}
	externs.macros.put "true" {".quote" true}
	externs.macros.put "false" {".quote" false}
	
	# Matching and assignment patterns
	define [toPattern pattern env wrapper] : match pattern 
		id [atom id] : object 
			whether : lambda [x] null
			assign : lambda [x locallyQ] {".set" [ex [if locallyQ {".local" id} id] env] [if wrapper {wrapper x} x]}
		{".id" id} [atom id] : object 
			whether : lambda [x] null
			assign : lambda [x locallyQ] {".set" [ex [if locallyQ {".local" id} id] env] [if wrapper {wrapper x} x]}
		{".quote" x} : object 
			whether : lambda [x] {"===" [ex pattern env] x}
			assign  : lambda [x locallyQ] {".unit"}
		{"." :: whatever} : object 
			whether : lambda [x] null
			assign : lambda [x locallyQ] {".set" [ex pattern env] [if wrapper {wrapper x} x]}
		{callee :: subpatterns} : piecewise
			([atom callee] && [env.macros.has callee] && [env.macros.get callee].toPattern) : begin
				return : [env.macros.get callee].toPattern pattern env wrapper
			([atom callee] && [env.macros.has callee]) : throw [new FormInvalidError pattern "Invalid Pattern"]
			true : begin
				local ms : subpatterns.map : [x] => [toPattern x env wrapper]
				local t : env.newt
				return : object 
					whether : lambda [x] [
						{"&&" 
							{".set" t 
								{{"." [ex callee env] {".quote" "unapply"}}
									x {".quote" ms.length}}}
							:: [ms.map [lambda [p j] 
									[p.whether {"." t {".quote" j}}]]]
							}.filter boole]
					assign : lambda [x locallyQ] {".begin" :: [ms.map [lambda [p j]
								[p.assign {"." t {".quote" j}} locallyQ]]] }
	
	externs.macros.put ".list" {.}
	set [[externs.macros.get ".list"].toPattern pattern env wrapper] : match pattern
		{".list" :: subpatterns} : begin 
			local ms : subpatterns.map : [x] => [toPattern x env wrapper]
			return : object 
				whether : lambda [x] [
					{"&&" 
						{{"." [externs.use "Array"] {".quote" "isArray"}} x}
						{"===" {"." x {".quote" "length"}} {".quote" ms.length}}
						:: [ms.map [lambda [p j] 
								[p.whether {"." x {".quote" j}}]]]
						}.filter boole]
				assign : lambda [x locallyQ] {".begin" :: [ms.map [lambda [p j] 
							[p.assign {"." x {".quote" j}} locallyQ]] :.concat {x}] }
	externs.macros.put ".conslist" {.}
	set [[externs.macros.get ".conslist"].toPattern pattern env wrapper] : match pattern
		{".conslist" :: subpatterns} : begin 
			local ms : [pattern.slice 1 (0 - 1)].map : [x] => [toPattern x env wrapper]
			local final : toPattern pattern.(pattern.length - 1) env
			return : object 
				whether : lambda [x] [
					{"&&" 
						{{"." [externs.use "Array"] {".quote" "isArray"}} x}
						{">=" {"." x {".quote" "length"}} {".quote" ms.length}}
						:: [
							[ms.map [lambda [p j] 
									[p.whether {"." x {".quote" j}}]]].concat
							[list [final.whether {{"." x {".quote" "slice"}} {".quote" ms.length}}]]]
						}.filter boole]
				assign : lambda [x locallyQ] [{".begin"
						:: [ms.map [lambda [p j]
								[p.assign {"." x {".quote" j}} locallyQ]]]
						}.concat [list [final.assign
							[if (wrapper)
								{{"." {{"." x {".quote" "slice"}} {".quote" ms.length}} {".quote" "map"}} wrapper}
								{{"." x {".quote" "slice"}} {".quote" ms.length}}] locallyQ]] :.concat {x}]
	externs.macros.put ".hash" {.}
	set [[externs.macros.get ".hash"].toPattern pattern env wrapper] : match pattern
		{".hash" :: subpatterns} : begin 
			local ms : subpatterns.map : lambda [pair] {pair.0 [toPattern pair.1 env wrapper]}
			return : object 
				whether : lambda [x] [
					{"&&" 
						x
						:: [ms.map [lambda [p] [p.1.whether {"." x {".quote" p.0}}]]]
					}.filter boole]
				assign : lambda [x locallyQ] : begin
					return {".begin" :: [ms.map [lambda [p] 
					[p.1.assign {"." x {".quote" p.0}} locallyQ]] :.concat {x}] }
	externs.macros.put ".xhash" {.}
	set [[externs.macros.get ".xhash"].toPattern pattern env wrapper] : match pattern
		{".xhash" :: subpatterns} : begin 
			local ms : subpatterns.map : lambda [pair] {[ex pair.0 env] [toPattern pair.1 env wrapper]}
			return : object 
				whether : lambda [x] [
					{"&&" 
						x
						:: [ms.map [lambda [p] [match p.0
							[{".quote" key} [p.1.whether {"." x p.0}]]
							[otherwise [let [t : env.newt] {".begin" {".set" t {"." x p.0}} [p.1.whether t]}]]]]]
					}.filter boole]
				assign : lambda [x locallyQ] {".begin" :: [ms.map [lambda [p] : match p.0
					[{".quote" key} [p.1.assign {"." x p.0} locallyQ]]
					[otherwise [let [t : env.newt] {".begin" {".set" t {"." x p.0}} [p.1.assign t locallyQ]}]]
				] :.concat {x}] }
	externs.macros.put ".quasiquote" {.}
	set [[externs.macros.get ".quasiquote"].toPattern pattern env wrapper] : match pattern
		{".quasiquote" :: subpatterns} : toPattern [deQuasiquote pattern.(1) 0 env] env wrapper
	externs.macros.put ".operatorPiece" {.}
	set [[externs.macros.get ".operatorPiece"].toPattern pattern env wrapper] : toPattern [opSegToRegular [pattern.slice 1] env] env wrapper
	externs.macros.put "&&" {.}
	set [[externs.macros.get "&&"].toPattern pattern env wrapper] : match pattern
		{"&&" :: subpatterns} : begin 
			local ms : subpatterns.map : [x] => [toPattern x env wrapper]
			return : object 
				whether : lambda [x] [begin \\
					local f : {"&&" :: [ms.map : lambda [p j] : p.whether x]}.filter boole
					if (f.length === 1) : return {".quote" true}
					return f
				]
				assign : lambda [x locallyQ] {".begin" :: [ms.map [lambda [p j] : p.assign x locallyQ] :.concat {x}] }
	externs.macros.put "||" {.}
	set [[externs.macros.get "||"].toPattern pattern env wrapper] : match pattern
		{"||" :: subpatterns} : begin 
			local ms : subpatterns.map : [x] => [toPattern x env wrapper]
			return : object 
				whether : lambda [x] [{"||" :: [ms.map : lambda [p j] : p.whether x]}.filter boole]
				assign : lambda [x locallyQ] {".unit"}

	define [boole x] [not [not x]]
	externs.macros.put "match" : lambda [form env wrapper] : begin 
		local pairs [form.slice 2]
		local t [env.newt]

		local f {".unit"}
		for [local j (pairs.length - 1)] (j >= 0) [dec j] : set f : match pairs.(j) 
			{pattern body} : begin 
				local pat : toPattern pattern env wrapper
				local cond : pat.whether t
				piecewise 
					cond {".if" cond {".begin" [pat.assign t true] [ex body env]} f}
					true {".begin" [pat.assign t true] [ex body env]}
			{pattern guard body} : begin 
				local pat : toPattern pattern env wrapper
				local cond : pat.whether t
				piecewise 
					cond : begin 
						local tc : env.newt
						* {".begin" 
							{".set" tc {".quote" false}} 
							{".if" cond {".begin" 
									[pat.assign t true]
									{".if" [ex guard env] 
										{".set" tc {".quote" true}} 
										{".set" tc {".quote" false}}}}}
							{".if" tc [ex body env] f}}
					true {".begin" 
						[pat.assign t true] 
						{".if" [ex guard env] [ex body env] f }}
			any f
		return {".begin" {".set" t [ex form.(1) env]} f}

	externs.macros.put "regex" : lambda [form env] : match form 
		{"regex" {".quote" s}} {".quote" [new RegExp s]}
		{"regex" {".quote" s} {".quote" flag}} {".quote" [new RegExp s flag]}
		{"regex" :: args} {".new" [externs.use "RegExp"] :: args}

	externs.macros.put "define-macro" : lambda [form env] : match form 
		{op {".quote" str} body} : ex {op str body} env
		{op name body} [atom name] : begin
			local coinit {
				.injectForm nothing
				.initFn nothing
			} 
			local ds [new Scope env]
			ds.declare "ex" true
			ds.declare "atom" true
			ds.declare "prim" true
			ds.declare "formOf" true
			ds.declare "scopeOf" true
			ds.declare "definingEnv" true
			ds.declare "externEnv" true
			ds.declare "require" true
			ds.declare "toPattern" true
			ds.declare "coinit" true
			ds.declare "FormInvalidError" true
			local macroG : new Function 
				ds.castName 'ex'
				ds.castName 'atom'
				ds.castName 'prim'
				ds.castName 'formOf'
				ds.castName 'scopeOf'
				ds.castName 'definingEnv'
				ds.castName 'externEnv'
				ds.castName 'require'
				ds.castName 'toPattern'
				ds.castName 'coinit'
				ds.castName 'FormInvalidError'
				escodegen.generate : patrisika.generate {".return" [ex body ds]} ds [lambda [form] {".return" form}]
			local macroFn [macroG ex [wrapForSyntacticClosure atom] [wrapForSyntacticClosure prim] [lambda [x] x.(1)] [lambda [x] x.(2)] env externs require toPattern coinit FormInvalidError]
			env.macros.put name : lambda [c e] : begin 
				local result [macroFn c e]
				local s [new Scope env]
				set s.hanging e
				set s.semiparent e
				return [ex result s]
			if coinit.initFn : coinit.initFn [env.macros.get name]
			return : if coinit.injectForm [ex coinit.injectForm env] {".unit"}
		otherwise {".unit"}

	externs.macros.put "macro-match" : lambda [form env] : match form 
		{"macro-match" c e :: patterns} : begin 
			local t [env.newt]
			local tx [env.newt]
			local tw [env.newt]
			return {".begin"
				{".set" t e}
				{".set" tw {".lambda" {tx} {".return" {".list" {".quote" ".syntactic-closure"} tx t}}}}
				[[externs.macros.get "match"] {"match" c :: patterns} env tw]}
		otherwise {".unit"}

	#ex [require './essential-macros.json'] externs
	set externs.pFamily 'r'

	return externs

define exports.Create Create
