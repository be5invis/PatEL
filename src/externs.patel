define patrisika [require "patrisika"]
define [atom x] [[typeof x] == "string"]
define [prim x] [[atom x] && x !== "&" && x !== "&!" && [x`0 === "." || [[regex "^\W+"].test x]]]
define Scope [require "patrisika"].Scope
define escodegen [require "escodegen"]
define util [require "util"]
define ex [require "./ex"].ex

define [FormInvalidError form reason] : begin {
	set this.reason reason
	set this.message reason
	set this.relatedForm form
	if [form && form.begins >= 0 && form.ends >= 0] : begin {
		set this.begins form.begins
		set this.ends form.ends
		inc this.message by ["\nAround (" + this.begins + " -- " + this.ends + ")"]
	}
	return null
}
set FormInvalidError.prototype : Object.create Error.prototype

# This file defines built-in macros of PatEL
define [Create] : begin {
	local externs [patrisika.DefaultExterns]
	set [externs.castName name] name
	externs.declare "require"
	externs.declare "exports"
	externs.declare "process"
	externs.declare "module"
	externs.declare "Error"
	
	define [operatorRename op] : lambda [form env] [ex (op :: [form.slice 1]) env]
	define [reportInvalid form reason] : throw : new FormInvalidError form reason

	#externs.macros.put "lambda" : operatorRename ".lambda"
	externs.macros.put "begin" : operatorRename ".begin"
	externs.macros.put "then" : operatorRename ".begin"
	externs.macros.put "else" : operatorRename ".begin"
	#externs.macros.put "if" : operatorRename ".if"
	externs.macros.put "while" : operatorRename ".while"
	externs.macros.put "try" : operatorRename ".try"
	externs.macros.put "is" : operatorRename ".is"
	externs.macros.put "<@" :operatorRename ".is"
	externs.macros.put "new" : operatorRename ".new"
	externs.macros.put "this" : operatorRename ".thisp"
	externs.macros.put "arguments" : operatorRename ".argsp"
	externs.macros.put "and" : operatorRename "&&"
	externs.macros.put "or" : operatorRename "||"
	externs.macros.put "not" : operatorRename "!"
	externs.macros.put "return" : operatorRename ".return"
	externs.macros.put "yield" : operatorRename ".yield"
	externs.macros.put "throw" : operatorRename ".throw"
	externs.macros.put "list" : operatorRename ".list"
	externs.macros.put "typeof" : operatorRename ".typeof"

	externs.macros.put "lambda" : lambda [form env] : match form {
		(car parameters body)	: ex ('.lambda' parameters body) env
		(car body)           	: ex ('.lambda' () body) env
		(car)                	: ex ('.lambda' () ('.unit')) body
		otherwise            	: reportInvalid otherwise "Invalid Lambda Formation"
	}
	externs.macros.put "function" : externs.macros.get "lambda"

	externs.macros.put "if" : lambda [form env] : match form {
		("if" test consequent)                                    	: ex ('.if' test consequent) env
		("if" test consequent alternate)                          	: ex ('.if' test consequent alternate) env
		("if" test ('then' :: consequents))                       	: ex ('.if' test ('.begin' :: consequents)) env
		("if" test ('then' :: consequents) ('else' :: alternates))	: ex ('.if' test ('.begin' :: consequents) ('.begin' :: alternates)) env
	}

	externs.macros.put ".conslist" : lambda [form env] {
		return (
			("." [ex (".list" :: [form.slice 1 [-1]]) env] (".quote" "concat"))
			[ex form.[form.length - 1] env]
		)
	}

	externs.macros.put "let" : lambda [form env] : begin {
		local pairs [form.slice 1 [0 - 1]]
		local args ()
		local paras ()
		for [local j 0] [j < pairs.length] [inc j] : match pairs`j {
			(arg param :: useless)	: begin { args.push arg; paras.push param }
			(arg param)           	: begin { args.push arg; paras.push param }
			(arg) [atom arg]      	: begin { args.push arg; paras.push [env.use arg] }
		}
		ex (".beta" args form.[form.length - 1] :: paras) env
	}

	externs.macros.put "object" : lambda [form env] : begin {
		local pairs : [form.slice 1].map : lambda [pair] : match pair {
			(property value :: useless)	: return (property [ex value env])
			(property value)           	: return (property [ex value env])
			(property) [atom property] 	: return (property [env.use property])
		}
		return (".hash" :: pairs)
	}

	externs.macros.put "piecewise" : lambda [form env] : match form {
		("piecewise" :: pairs) : begin {
			local f (".unit")
			for [local j [pairs.length - 1]] [j >= 0] [set j [j - 1]] {
				set f (".if" [ex pairs`j`0 env] [ex pairs`j`1 env] f)
			}
			return f
		}
	}

	define [AssignWithMod left right mod env locallyQ] : match left {
			("local" a)       	: AssignWithMod a left right mod env true
			(".local" a)      	: AssignWithMod a left right mod env true
			(".list" :: items)	: Assign left (mod right) env locallyQ
			(".hash" :: items)	: Assign left (mod right) env locallyQ
	
			(callee :: paras) : piecewise {
				[prim callee] (".set" [ex left env] [ex (mod right) env])
				[atom callee] : piecewise {
					locallyQ (".set" 
						[ex (".local" callee) env] 
						[ex (mod (".lambda" (::paras) right)) env])
					true (".set" 
						[ex callee env]
						[ex (mod (".lambda" (::paras) right)) env])
				}
				true (".set" [ex callee env] [ex (mod (".lambda" (::paras) right)) env])
			}
	
			any : Assign ex left (mod right) env locallyQ
	}
	define [Assign left right env locallyQ] : match left {
		id [atom id] : piecewise {
			locallyQ (".set" [ex (".local" id) env] [ex right env])
			true     (".set" [ex left env] [ex right env])
		}

		("local" a) : Assign a right env true
		(".local" a) : Assign a right env true

		(".list" :: items) : begin {
			local t [env.newt]
			local assignments (".begin" (".set" t [ex right env]))
			for [local j 0] [j < items.length] [inc j] {
				assignments.push : Assign items`j ("." t (".quote" j)) env locallyQ
			}
			assignments.push t
			return assignments
		}

		(".hash" :: items) : begin {
			local t [env.newt]
			local assignments (".begin" (".set" t [ex right env]))
			for [local j 0] [j < items.length] [inc j] {
				assignments.push : Assign items`j`1 ("." t (".quote" items`j`0))  env locallyQ
			}
			assignments.push t
			return assignments
		}

		(callee :: paras) : piecewise {
			[prim callee] (".set" [ex left env] [ex right env])
			[atom callee] : piecewise {
				locallyQ (".set" 
					[ex (".local" callee) env] 
					[ex (".lambda" (::paras) right) env])
				true (".set" 
					[ex callee env]
					[ex (".lambda" (::paras) right) env])
			}
			true (".set" [ex callee env] [ex (".lambda" (::paras) right) env])
		}
		any : throw [new SyntaxError "Invalid Assignment"]
	}

	externs.macros.put "define" : lambda [form env] : match form {
		(op modifer left right) : AssignWithMod left right modifer env true
		(op left right) : Assign left right env true
		(op left) [atom left] : return (".local" left)
		any : throw [new SyntaxError "Invalid Assignment"]
	}
	externs.macros.put "local" : externs.macros.get "define"
	externs.macros.put "set" : lambda [form env] : match form {
		(op left right) : Assign left right env false
		any : throw [new SyntaxError "Invalid Assignment"]
	}

	externs.macros.put "inc" : lambda [form env] : match form {
		(op id)           	[Assign id ("+" id (".quote" 1)) env false]
		(op id shift)     	[Assign id ("+" id shift) env false]
		(op id "by" shift)	[Assign id ("+" id shift) env false]
	}
	externs.macros.put "dec" : lambda [form env] : match form {
		(op id)           	[Assign id ("-" id (".quote" 1)) env false]
		(op id shift)     	[Assign id ("-" id shift) env false]
		(op id "by" shift)	[Assign id ("-" id shift) env false]
	}

	externs.macros.put "for" : lambda [form env] : match form {
		("for" init test step body) (".begin"
			[ex init env]
			(".while" [ex test env] (".begin" [ex body env] [ex step env])))
	}

	externs.macros.put "foreach" : lambda [form env] : match form {
		("foreach" varid range body) : begin {
			local tR [env.newt]
			local t  [env.newt]
			return (".begin"
				(".set" tR [ex range env])
				(".while" 
					("!" ("." (".set" t (("." tR (".quote" "next")))) (".quote" "done"))) 
					(".begin"
						[Assign varid ("." t (".quote" "value")) env false]
						[ex body env])))
		}
	}

	externs.macros.put "this" (".thisp")
	externs.macros.put "arguments" (".argsp")
	externs.macros.put "nothing" (".unit")
	externs.macros.put "undefined" (".unit")
	externs.macros.put "null" (".quote" null)
	externs.macros.put "true" (".quote" true)
	externs.macros.put "false" (".quote" false)

	define [boole x] [not [not x]]
	externs.macros.put "match" : lambda [form env] : begin {
		local pairs [form.slice 2]
		local t [env.newt]

		define [matchQ pattern] : match pattern {
			id [atom id] : object {
				whether : lambda [x] null
				assign : lambda [x] (".set" [ex (".local" pattern) env] x)
			}
			(".quote" x) : object {
				whether : lambda [x] ("===" [ex pattern env] x)
				assign  : lambda [x] (".unit")
			}
			("." :: whatever) : object {
				whether : lambda [x] null
				assign : lambda [x] (".set" [ex pattern env] x)
			}
			(".list" :: subpatterns) : begin {
				local ms : subpatterns.map matchQ
				return : object {
					whether : lambda [x] [
						("&&" 
							(".is" x [externs.use "Array"]) 
							("===" ("." x (".quote" "length")) (".quote" ms.length)) 
							:: [ms.map [lambda [p j] 
								[p.whether ("." x (".quote" j))]]]
						).filter boole]
					assign : lambda [x] (".begin" :: [ms.map [lambda [p j] 
						[p.assign ("." x (".quote" j))]]] )
				}
			}
			(".conslist" :: subpatterns) : begin {
				local ms : [pattern.slice 1 [0 - 1]].map matchQ
				local final : matchQ pattern.[pattern.length - 1]
				return : object {
					whether : lambda [x] [
						("&&" 
							(".is" x [externs.use "Array"]) 
							(">=" ("." x (".quote" "length")) (".quote" ms.length)) 
							:: [
								[ms.map [lambda [p j] 
									[p.whether ("." x (".quote" j))]]].concat
								[list [final.whether (("." x (".quote" "slice")) (".quote" j))]]]
						).filter boole]
					assign : lambda [x] [(".begin"
						:: [ms.map [lambda [p j] 
							[p.assign ("." x (".quote" j))]]] 
						).concat [list [final.assign 
							(("." x (".quote" "slice")) (".quote" ms.length))]]]
				}
			}
			(callee :: subpatterns) : begin {
				local ms : subpatterns.map matchQ
				local t : env.newt
				return : object {
					whether : lambda [x] [
						("&&" 
							(".set" t 
								(("." [ex callee env] (".quote" "unapply"))
									x (".quote" ms.length)))
							:: [ms.map [lambda [p j] 
								[p.whether ("." t (".quote" j))]]]
						).filter boole]
					assign : lambda [x] (".begin" :: [ms.map [lambda [p j]
						[p.assign ("." t (".quote" j))]]] )
				}
			}
		}

		local f (".unit")
		for [local j [pairs.length - 1]] [j >= 0] [dec j] : set f : match pairs`j {
			(pattern body) : begin {
				local pat : matchQ pattern
				local cond : pat.whether t
				piecewise {
					cond (".if" cond (".begin" [pat.assign t] [ex body env]) f)
					true (".begin" [pat.assign t] [ex body env])
				}
			}
			(pattern guard body) : begin {
				local pat : matchQ pattern
				local cond : pat.whether t
				piecewise {
					cond : begin {
						local tc : env.newt
						* (".begin" 
							(".set" tc (".quote" false)) 
							(".if" cond (".begin" 
								[pat.assign t]
								(".if" [ex guard env] 
									(".set" tc (".quote" true)) 
									(".set" tc (".quote" false)))))
							(".if" tc [ex body env] f))
					}
					true (".begin" 
						[pat.assign t] 
						(".if" [ex guard env] [ex body env] f ))
				}
			}
			any f
		}
		return (".begin" (".set" t [ex form`1 env]) f)
	}

	externs.macros.put "regex" : lambda [form env] : match form {
		("regex" (".quote" s)) (".quote" [new RegExp s])
		("regex" (".quote" s) (".quote" flag)) (".quote" [new RegExp s flag])
		("regex" :: args) (".new" [externs.use "RegExp"] :: args)
	}

	externs.macros.put "with-semantics" : lambda [form env] : begin {
		local body form`[form.length - 1]
		local derived [new Scope env]
		for [local j 1] [j < form.length - 1] [inc j by 1] : begin {
			local macroBodyScope [new Scope [Create]]
			macroBodyScope.declare "evaluate" true
			macroBodyScope.declare "Assign" true
			macroBodyScope.declare "externalMacros" true
			macroBodyScope.declare "atom" true
			macroBodyScope.declare "prim" true
			macroBodyScope.declare "top" true
			local macroName form`j`0
			local macroBody form`j`1
			local bodyCode : escodegen.generate : patrisika.generate (".return" [ex macroBody macroBodyScope]) macroBodyScope [lambda [form] (".return" form)]
			local macroFn : new Function {
				macroBodyScope.castName "evaluate"
				macroBodyScope.castName "Assign"
				macroBodyScope.castName "externalMacros"
				macroBodyScope.castName "atom"
				macroBodyScope.castName "prim"
				macroBodyScope.castName "top"
				* bodyCode
			}
			derived.macros.put macroName [macroFn ex Assign env.macros atom prim externs]
		}
		return : ex body derived
	}

	return externs
}

define exports.Create Create
