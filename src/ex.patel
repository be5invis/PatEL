define Scope [require "patrisika"].Scope
define [atom x] [[typeof x] == "string"]
define [prim x] [[atom x] && x !== "&" && x !== "&!" && [x`0 === "." || [[regex "^\W+"].test x]]]

define [FormInvalidError form reason] : begin {
	set this.reason reason
	set this.message reason
	set this.relatedForm form
	if [form && form.begins >= 0 && form.ends >= 0] : begin {
		set this.begins form.begins
		set this.ends form.ends
		inc this.message by ["\nAround (" + this.begins + " -- " + this.ends + ")"]
	}
	return null
}
set FormInvalidError.prototype : Object.create Error.prototype

define [NodeTranslation fn] : lambda [form] : begin {
	local res : fn.apply this arguments
	if [form && form.begins >= 0] : set res.begins form.begins
	if [form && form.ends >= 0] : set res.ends form.ends
	return res
}

# Function [ex form env]: Expand macros and do scoping
define ex : NodeTranslation : lambda [form env] : match form {
	(".quote" :: x) : return (".quote" :: x)
	(".id" :: x) : return (".id" :: x)
	(".t" :: x) : return (".t" :: x)
	(".lambda" (::args) body) : begin {
		define derived [new Scope env]
		for [local j 0] [j < args.length] [inc j] : begin {
			derived.declare args`j true
			set args`j : derived.use args`j
		}
		return (".lambda.scoped" args [ex body derived] derived)
	}
	(".beta" (::args) body :: params) : begin {
		define derived [new Scope env]
		for [local j 0] [j < args.length] [inc j] : begin {
			derived.declare args`j true
			set args`j : derived.use args`j
		}
		for [local j 0] [j < args.length] [inc j] : begin {
			set params`j [ex params`j env]
		}
		return (".beta.scoped" args [ex body derived] derived :: params)
	}
	(".try" block (param) handler) : begin {
		env.declare param
		return (".try" [ex block env] ([env.use param]) [ex handler env])
	}
	(".hash" :: args) : begin {
		local a ()
		local allKeysAreQuotes true
		for [local j 1] [j < form.length] [inc j] : begin {
			local key [ex form`j`0 env]
			local value [ex form`j`1 env]
			match key {
				(".quote" x) nothing
				otherwise : set allKeysAreQuotes false
			}
			a.push (key value)
		}
		if allKeysAreQuotes {
			then : return (".hash" :: [a.map [lambda [pair] (pair`0`1 pair`1)]])
			else : return : let [t [env.newt]] (".begin" (".set" t (".hash")) :: [[a.map [lambda [pair] (".set" ("." t pair`0) pair`1)]].concat (t)])
		}

	}
	(".local" x) : begin {
		env.declare x
		return [env.use x]
	}
	(callee :: args) : begin {
		if [and [atom callee] [env.macros.has callee]] : begin {
			return [[env.macros.get callee] form env]
		}
		if [not [prim callee]] : set callee [ex callee env]
		local a (callee)
		for [local j 1] [j < form.length] [inc j] : begin {
			set a`j [ex form`j env]
		}
		return a
	}
	x [[atom x] && [env.macros.has x] && [not [[env.macros.get x] <@ Function]]] : return [env.macros.get x]
	x [prim x] : return x
	x [atom x] : return [env.use x]
	any : return any
}

define [checkEvaluated form] : if [form && form <@ Array] : begin {
	if form.unevaluated : throw : new FormInvalidError form "Unevaluated subform"
	form.forEach checkEvaluated
}

define [exports.pass form globalScope] [ex form globalScope]
define exports.ex ex
define exports.checkEvaluated checkEvaluated