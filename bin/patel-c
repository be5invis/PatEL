#!/usr/bin/env node
var os = require('os');
var fs = require('fs');
var util = require('util');
var resumer = require('resumer');
var yargs = require('yargs')
	.alias('o', 'output-into')
	.alias('?', 'help')
	.alias('l', 'line')
	.boolean(['use-dev', 'dump-ast', 'dump-expanded', 'dump-regularized', 'dump-transformed'])
	.describe('?', 'Displays this help.')
	.describe('l', 'Compile one-line script.')
	.describe('o', 'Output sfd path. When absent, the result sfd is written to STDOUT.');


var argv = yargs.argv;
if(argv.help){ process.stderr.write(yargs.help()); return };
if(argv['use-dev']) { 
	var patel = require('../index-dev');
} else {
	var patel = require('../index');
}

var instream = function(){
	if(argv.l) {
		var s = resumer();
		s.queue(argv.l);
		setTimeout(function(){ s.end() }, 1);
		return s;
	} else if(argv._[0]) {
		return fs.createReadStream(argv._[0])
	} else { 
		return process.stdin
	}
}();
var outstream = argv.o ? fs.createWriteStream(argv.o, { encoding: 'utf-8' }): process.stdout;


function generateLineAndColumnMap(input){
	var lines = [];
	var columns = [];
	var line = 1;
	var col = 0
	for(var j = 0; j < input.length; j++) {
		lines[j] = line;
		columns[j] = col;
		if(input[j] === '\n') { line += 1; col = 0 }
		else { col += 1 }
	};
	return {
		line: lines,
		column: columns
	}
}

function deepcopy(form){
	if(form instanceof Array) return form.map(deepcopy)
	else return form;
}
function dump(form){
	if(process.stdout !== outstream) outstream.write(JSON.stringify(form))
	else outstream.write(util.inspect(deepcopy(form), {depth: null}) + '\n')
}
function printSourceLines(stream, lines, firstLineNumber){
	stream.write(lines.map(function(line, k){ return '  ' + (firstLineNumber + k) + '\t| ' + line}).join('\n') + '\n')
}

var input = '';
instream.on('data', function(buf){
	input += buf.toString() 
});
instream.on('end', function(){
	input += '\n\n\n';
	if(argv['dump-input']) { outstream.write(input); return }
	var lcmap = generateLineAndColumnMap(input);
	var lines = input.split('\n');
	var gs = patel.globals();
	try {
		var ast = patel.parse(input);
		try {
			if(argv['dump-ast']) { dump(ast); return }
			var xast = patel.ex(ast, gs);
			patel.checkEvaluated(xast);
			if(argv['dump-expanded']) { dump(xast); return }
			var rast = patel.regularize(xast, gs);
			if(argv['dump-regularized']) { dump(rast); return }
			var tast = patel.pat2esc(rast, gs, lcmap);
			if(argv['dump-transformed']) { dump(tast); return }
			var result = patel.generateCode(tast, {sourceMap: argv._[0] || '(stdin)', sourceMapWithCode: true})
			if(argv.source_map) {
				outstream.write(result.map.toString() + '\n');
			} else {
				if(os.platform() === 'win32') outstream.write('\uFEFF');
				outstream.write(result.code + '\n');
			}
		} catch(ex) {
			if(ex.begins >= 0 && ex.ends >= 0) {
				util.error(ex);
				var ljBegins = lcmap.line[ex.begins] - 1
				var ljEnds = lcmap.line[ex.ends] - 1
				if(ljEnds - ljBegins < 3) {
					printSourceLines(process.stderr,lines.slice(ljBegins, ljEnds + 1), ljBegins + 1);
				} else {
					printSourceLines(process.stderr,lines.slice(ljBegins, ljBegins + 2), ljBegins + 1);
					process.stderr.write("......\n");
					printSourceLines(process.stderr,lines.slice(ljEnds - 1, ljEnds + 1), ljEnds);
				}
			} else {
				util.error(ex.stack || ex);
			}
			return;
		}
	} catch(ex) {
		process.stderr.write(ex.message + '\n');
		process.stderr.write("At Line " + ex.line + ', Column ' + ex.column + '\n');
		var line = input.split('\n')[ex.line - 1]
		process.stderr.write(line + '\n');
		process.stderr.write(line.replace(/\S/g, ' ').slice(0, ex.column) + '^\n');
		return;
	}
});