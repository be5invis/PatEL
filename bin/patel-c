#!/usr/bin/env node
var os = require('os');
var fs = require('fs');
var util = require('util');
var resumer = require('resumer');
var yargs = require('yargs')
	.alias('o', 'output-into')
	.alias('?', 'help')
	.alias('l', 'line')
	.boolean(['use-dev', 'dump-ast', 'dump-expanded', 'dump-regularized', 'dump-transformed', 'strict', 'optimize', 'mangle', 'ugly'])
	.describe('?', 'Displays this help.')
	.describe('l', 'Compile one-line script.')
	.describe('o', 'Output sfd path. When absent, the result sfd is written to STDOUT.');
var tty = require('tty');

var argv = yargs.argv;
if(argv.help){ process.stderr.write(yargs.help()); return };

if(argv['use-dev']) { 
	var patel = require('../index-dev');
} else {
	var patel = require('../index');
}
var plex = require('../plex');

var instream = function(){
	if(argv.l) {
		var s = resumer();
		s.queue(argv.l);
		setTimeout(function(){ s.end() }, 1);
		return s;
	} else if(argv._[0]) {
		return fs.createReadStream(argv._[0])
	} else { 
		return process.stdin
	}
}();
var outstream = argv.o ? fs.createWriteStream(argv.o, { encoding: 'utf-8' }): process.stdout;

function generateLineAndColumnMap(input){
	var lines = [];
	var columns = [];
	var line = 1;
	var col = 0
	for(var j = 0; j < input.length; j++) {
		lines[j] = line;
		columns[j] = col;
		if(input[j] === '\n') { line += 1; col = 0 }
		else { col += 1 }
	};
	return {
		line: lines,
		column: columns
	}
}

function deepcopy(form){
	if(form instanceof Array) return form.map(deepcopy)
	else return form;
}
function dumpStruct(form){
	if(!outstream.isTTY) outstream.write(JSON.stringify(form))
	else outstream.write(util.inspect(deepcopy(form), {depth: null}) + '\n')
}
function dumpString(s){
	outstream.write(s)
}
function printSourceLines(stream, lines, firstLineNumber){
	stream.write(lines.map(function(line, k){ return '  ' + (firstLineNumber + k) + '\t| ' + line}).join('\n') + '\n')
}
function reportError(ex){
	if(ex.begins >= 0 && ex.ends >= 0) {
		console.error(ex.message);
		if(ex.within && ex.within.input) {
			var lcmap = generateLineAndColumnMap(ex.within.input);
			var lines = ex.within.input.split("\n");
			var ljBegins = lcmap.line[ex.begins] - 1;
			var ljEnds = lcmap.line[ex.ends] - 1;
			if(ex.within.file){
				process.stderr.write(ex.within.file + "\n")
			}
			if(ljEnds - ljBegins < 3) {
				printSourceLines(process.stderr, lines.slice(ljBegins, ljEnds + 1), ljBegins + 1);
			} else {
				printSourceLines(process.stderr, lines.slice(ljBegins, ljBegins + 2), ljBegins + 1);
				process.stderr.write("......\n");
				printSourceLines(process.stderr, lines.slice(ljEnds - 1, ljEnds + 1), ljEnds);
			}
		}
	} else {
		console.error(ex.stack || ex);
	}
}

var input = '';
instream.on('data', function(buf){
	input += buf.toString()
});
instream.on('end', function(){
	var compileResult = plex.compile(input, {
		patel: patel,
		from: argv.l ? {argv : 'l'} : argv._[0] ? {file : argv._[0]} : {stream : 'stdin'},
		strict: argv.strict,
		optimize: argv.optimize,
		mangle: argv.mangle,
		ugly: argv.ugly,
		
		'dump-input': argv['dump-input'],
		'dump-ast': argv['dump-ast'],
		'dump-expanded': argv['dump-expanded'],
		'dump-regularized': argv['dump-regularized'],
		'dump-transformed': argv['dump-transformed']
	}, function(ex, result, dump){
		if(ex){
			if(ex.suberrors) {
				for(var j = 0; j < ex.suberrors.length; j++){ reportError(ex.suberrors[j]) }
			} else {
				reportError(ex);
			}
		} else if(result){
			if(argv['source-map']) {
				outstream.write(result.map.toString() + '\n');
			} else {
				if(os.platform() === 'win32') outstream.write('\uFEFF');
				outstream.write(result.code + '\n');
			}
		} else {
			if(typeof dump === 'string') dumpString(dump)
			else dumpStruct(dump)
		}
	});
	if(!compileResult) return;
});