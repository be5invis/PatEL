#!/usr/bin/env node
var os = require('os');
var fs = require('fs');
var util = require('util');
var resumer = require('resumer');
var yargs = require('yargs')
	.alias('o', 'output-into')
	.alias('?', 'help')
	.alias('l', 'line')
	.boolean(['use-dev', 'dump-ast', 'dump-expanded', 'dump-regularized', 'dump-transformed', 'strict', 'optimize', 'mangle', 'ugly'])
	.describe('?', 'Displays this help.')
	.describe('l', 'Compile one-line script.')
	.describe('o', 'Output sfd path. When absent, the result sfd is written to STDOUT.');
var tty = require('tty');
var esmangle = require('esmangle');

var argv = yargs.argv;
if(argv.help){ process.stderr.write(yargs.help()); return };
if(argv['use-dev']) { 
	var patel = require('../index-dev');
} else {
	var patel = require('../index');
}

var instream = function(){
	if(argv.l) {
		var s = resumer();
		s.queue(argv.l);
		setTimeout(function(){ s.end() }, 1);
		return s;
	} else if(argv._[0]) {
		return fs.createReadStream(argv._[0])
	} else { 
		return process.stdin
	}
}();
var outstream = argv.o ? fs.createWriteStream(argv.o, { encoding: 'utf-8' }): process.stdout;


function generateLineAndColumnMap(input){
	var lines = [];
	var columns = [];
	var line = 1;
	var col = 0
	for(var j = 0; j < input.length; j++) {
		lines[j] = line;
		columns[j] = col;
		if(input[j] === '\n') { line += 1; col = 0 }
		else { col += 1 }
	};
	return {
		line: lines,
		column: columns
	}
}

function deepcopy(form){
	if(form instanceof Array) return form.map(deepcopy)
	else return form;
}
function dump(form){
	if(!outstream.isTTY) outstream.write(JSON.stringify(form))
	else outstream.write(util.inspect(deepcopy(form), {depth: null}) + '\n')
}
function printSourceLines(stream, lines, firstLineNumber){
	stream.write(lines.map(function(line, k){ return '  ' + (firstLineNumber + k) + '\t| ' + line}).join('\n') + '\n')
}
function reportError(ex, lcmap, lines){
	if(ex.begins >= 0 && ex.ends >= 0) {
		console.error(ex.message);
		if(ex.within && ex.within.input) {
			var lcmap = generateLineAndColumnMap(ex.within.input);
			var lines = ex.within.input.split("\n");
			var ljBegins = lcmap.line[ex.begins] - 1;
			var ljEnds = lcmap.line[ex.ends] - 1;
			if(ex.within.file){
				process.stderr.write(ex.within.file + "\n")
			}
			if(ljEnds - ljBegins < 3) {
				printSourceLines(process.stderr, lines.slice(ljBegins, ljEnds + 1), ljBegins + 1);
			} else {
				printSourceLines(process.stderr, lines.slice(ljBegins, ljBegins + 2), ljBegins + 1);
				process.stderr.write("......\n");
				printSourceLines(process.stderr, lines.slice(ljEnds - 1, ljEnds + 1), ljEnds);
			}
		}
	} else {
		console.error(ex.stack || ex);
	}
}

var input = '';
instream.on('data', function(buf){
	input += buf.toString()
});
instream.on('end', function(){
	input += '\n\n\n';
	if(argv['dump-input']) { outstream.write(input); return }
	var gs0 = patel.globals();
	gs0.strict = argv.strict;
	
	var lcmap = generateLineAndColumnMap(input);
	var lines = input.split("\n");
	// macros returning information about the file
	gs0.macros.put("input-path", function(){
		if(argv.l) return ['.quote', '|argv.l']
		if(argv._[0]) return ['.quote', argv._[0]]
		return ['.quote', '|-']
	});
	var gs = new patel.Scope(gs0);
	gs.strict = argv.strict;
	
	try {
		var ast = patel.parse(input, {within: { file: gs.macros.get('input-path')()[1], input: input }});
	} catch(ex){
		process.stderr.write(ex.message + '\nAt Line ' + ex.line + ', Column' + ex.column);
		process.exit(1);
	};
	
	try {
		if(argv['dump-ast']) { dump(ast); return }
		var xastP = patel.ex(patel.prepareAST, gs0);
		var xast = ['.begin', xastP, patel.ex(ast, gs)];
		patel.checkEvaluated(xast);
		if(argv['dump-expanded']) { dump(xast); return }
		var rast = patel.regularize(xast, gs);
		if(argv['dump-regularized']) { dump(rast); return }
		var tast = patel.pat2esc(rast, gs, lcmap);
		if(tast.type === "BlockStatement") {
			tast.type = "Program"
		} else {
			tast = {
				type: "Program",
				body: [tast]
			}
		}
		if(argv['dump-transformed']) { dump(tast); return }
		if(argv.optimize) tast = esmangle.optimize(tast);
		if(argv.mangle) tast = esmangle.mangle(tast);
		
		var options = {sourceMap: argv._[0] || '(stdin)', sourceMapWithCode: true};
		if(argv.ugly) {
			options.format = {
				renumber: true,
				hexadecimal: true,
				escapeless: false,
				compact: true,
				semicolons: false,
				parentheses: false
			}
		}
		var result = patel.generateCode(tast, options)
		
		if(argv.source_map) {
			outstream.write(result.map.toString() + '\n');
		} else {
			if(os.platform() === 'win32') outstream.write('\uFEFF');
			outstream.write(result.code + '\n');
		}
	} catch(ex) {
		if(ex && ex.suberrors) {
			for(var j = 0; j < ex.suberrors.length; j++){ reportError(ex.suberrors[j], lcmap, lines) }
		}
		else reportError(ex, lcmap, lines);
		process.exit(1);
	}
});